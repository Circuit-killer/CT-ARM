{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nThe 1\nst\n Arduino/Genuino UNO compatible 32-bit ARM Cortex-M0 running at 5V, fully shield compatible from Cytron Technologies!\n\n\nYes, ARM is quite famous architecture, it almost consume entire smart phone market. Most of the smart phone you have is ARM based. And now, ARM has also invade the microcontroller sector :) With the 32-bit ARM processor and high processor speed, not to forget the rich peripherals, this ARM Cortex-M0 microcontroller offer 6X the power of 8-bit microcontroller.\n\n\nWe are excited about ARM microcontroller too and we are working hard to integrate it into Arduino Ecosystem. Now it is ready, and we would like you to try it! We have developed the libraries and the json files to include everything you need into Arduino IDE. Nevertheless, it still needs more developers and lovers to nurture it \n So if you are familiar with Arduino and ARM, please grab one, kick start it and work with us to grow the community.\n\n\nThis is CT-ARM, an Arduino UNO R3 compatible 32-bit ARM Cortex-M0 microcontroller board. It is compatible with Genunio UNO R3.\n\n\nTechnical specs\n\n\n\n\n\n\n\n\nFEATURES\n\n\nCT-ARM\n\n\n\n\n\n\n\n\n\n\nMicrocontroller\n\n\nNUC131LD2AE\n\n\n\n\n\n\nArchitecture\n\n\n32-Bit ARM Cortex M0\n\n\n\n\n\n\nInput voltage (Recommended)\n\n\n7 - 15V\n\n\n\n\n\n\nInput voltage (Limit)\n\n\n6 - 20V\n\n\n\n\n\n\nOperating voltage\n\n\n5VDC\n\n\n\n\n\n\nClock Speed\n\n\n50MHz\n\n\n\n\n\n\nSRAM size\n\n\n8KB\n\n\n\n\n\n\nFlash size (program memory)\n\n\n64KB\n\n\n\n\n\n\nEEPROM/Data flash\n\n\n4KB\n\n\n\n\n\n\nDigital IO\n\n\n20\n\n\n\n\n\n\nAnalog input (ADC)\n\n\n6\n\n\n\n\n\n\nPWM\n\n\n16\n\n\n\n\n\n\nExternal Interrupts\n\n\n16\n\n\n\n\n\n\nUART\n\n\n5 + 1\n\n\n\n\n\n\nSPI\n\n\n1\n\n\n\n\n\n\nI2C\n\n\n1\n\n\n\n\n\n\nSoftwareSerial\n\n\nAll IO pins\n\n\n\n\n\n\nProgramming Chip\n\n\nFT231X\n\n\n\n\n\n\nProgramming IDE\n\n\nArduino IDE\n\n\n\n\n\n\n\n\n\n\nCompatible in Arduino IDE\n\n\nFundamental Arduino Library included\n\n\nUtilising most commonly used USB MicroB cable\n\n\n\n\nDownloads\n\n\nEagle Files\n\n\n\n\nSchematics\n\n\nBoard Layout\n\n\n\n\nDatasheets\n\n\n\n\nNUC131 Datasheet\n\n\nNUC131 Technical Reference Manual\n\n\n\n\nUser Manual\n\n\n\n\nCT-ARM User Manual", 
            "title": "Introduction"
        }, 
        {
            "location": "/#overview", 
            "text": "The 1 st  Arduino/Genuino UNO compatible 32-bit ARM Cortex-M0 running at 5V, fully shield compatible from Cytron Technologies!  Yes, ARM is quite famous architecture, it almost consume entire smart phone market. Most of the smart phone you have is ARM based. And now, ARM has also invade the microcontroller sector :) With the 32-bit ARM processor and high processor speed, not to forget the rich peripherals, this ARM Cortex-M0 microcontroller offer 6X the power of 8-bit microcontroller.  We are excited about ARM microcontroller too and we are working hard to integrate it into Arduino Ecosystem. Now it is ready, and we would like you to try it! We have developed the libraries and the json files to include everything you need into Arduino IDE. Nevertheless, it still needs more developers and lovers to nurture it   So if you are familiar with Arduino and ARM, please grab one, kick start it and work with us to grow the community.  This is CT-ARM, an Arduino UNO R3 compatible 32-bit ARM Cortex-M0 microcontroller board. It is compatible with Genunio UNO R3.", 
            "title": "Overview"
        }, 
        {
            "location": "/#technical-specs", 
            "text": "FEATURES  CT-ARM      Microcontroller  NUC131LD2AE    Architecture  32-Bit ARM Cortex M0    Input voltage (Recommended)  7 - 15V    Input voltage (Limit)  6 - 20V    Operating voltage  5VDC    Clock Speed  50MHz    SRAM size  8KB    Flash size (program memory)  64KB    EEPROM/Data flash  4KB    Digital IO  20    Analog input (ADC)  6    PWM  16    External Interrupts  16    UART  5 + 1    SPI  1    I2C  1    SoftwareSerial  All IO pins    Programming Chip  FT231X    Programming IDE  Arduino IDE      Compatible in Arduino IDE  Fundamental Arduino Library included  Utilising most commonly used USB MicroB cable", 
            "title": "Technical specs"
        }, 
        {
            "location": "/#downloads", 
            "text": "", 
            "title": "Downloads"
        }, 
        {
            "location": "/#eagle-files", 
            "text": "Schematics  Board Layout", 
            "title": "Eagle Files"
        }, 
        {
            "location": "/#datasheets", 
            "text": "NUC131 Datasheet  NUC131 Technical Reference Manual", 
            "title": "Datasheets"
        }, 
        {
            "location": "/#user-manual", 
            "text": "CT-ARM User Manual", 
            "title": "User Manual"
        }, 
        {
            "location": "/How_to_Install/", 
            "text": "Boards Manager\n\n\nThis is the suggested installation method for end users.\n\n\nPrerequisites\n\n\n\n\nArduino 1.6.7 and above from \nArduino official website\n.\n\n\nInternet connection\n\n\n\n\nInstructions\n\n\n\n\nStart Arduino IDE and open \nPreferences\n window.\n\n\nEnter \nhttps://cytrontechnologies.github.io/package_cytron_index.json\n into \nAdditional Boards Manager URLs\n field. You can add multiple URLs, separating them with commas.\n\n\nOpen Boards Manager from Tools \n Board menu and find \nCytron ARM Boards by Cytron Technologies Sdn Bhd\n platform.\n\n\nSelect the version you need from a drop-down box.\n\n\nClick \ninstall\n button.\n\n\nAfter the installation is completed, close the Board Manager window.\n\n\nSelect your CT-ARM board from Tools \n Board menu.\n\n\n\n\nUsing git version\n\n\nThis is the suggested installation method for contributors and library\ndevelopers.\n\n\nPrerequisites\n\n\n\n\nArduino 1.6.7 (or newer, if you know what you are doing)\n\n\nPython 2.7\n\n\ngit\n\n\nterminal, console, or command prompt (depending on you OS)\n\n\nInternet connection\n\n\n\n\nInstructions\n\n\n\n\nOpen the console and go to Arduino directory. This can be either your\n   \nsketchbook\n directory (usually \nDocuments\n/Arduino\n), or the\n   directory of Arduino application itself, the choice is up to you.\n\n\nClone this repository into hardware/cytron_arm/ct-arm directory.\n   Alternatively, clone it elsewhere and create a symlink, if your OS\n   supports them.\n\n\n\n\ncd hardware\nmkdir -p cytron_arm\ncd cytron_arm\ngit clone https://github.com/CytronTechnologies/CT-ARM.git ct-arm\n\n\n\n\n\nYou should end up with the following directory structure:\n\nArduino\n|\n--- hardware\n   |\n   --- cytron_arm\n       |\n       --- CT-ARM\n           |\n           --- cores\n           --- docs\n           --- libraries\n           --- tools\n           --- package\n           --- system\n           --- variants\n           --- platform.txt\n           --- programmers.txt\n           --- README.md\n           --- boards.txt\n           --- LICENSE.md\n\n\n\n\n\n\n\nDownload binary tools\n\n\n\n\ncd ct-arm/tools\npython get.py\n\n\n\n\n\n\n\nRestart Arduino", 
            "title": "How to Install"
        }, 
        {
            "location": "/How_to_Install/#boards-manager", 
            "text": "This is the suggested installation method for end users.", 
            "title": "Boards Manager"
        }, 
        {
            "location": "/How_to_Install/#prerequisites", 
            "text": "Arduino 1.6.7 and above from  Arduino official website .  Internet connection", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/How_to_Install/#instructions", 
            "text": "Start Arduino IDE and open  Preferences  window.  Enter  https://cytrontechnologies.github.io/package_cytron_index.json  into  Additional Boards Manager URLs  field. You can add multiple URLs, separating them with commas.  Open Boards Manager from Tools   Board menu and find  Cytron ARM Boards by Cytron Technologies Sdn Bhd  platform.  Select the version you need from a drop-down box.  Click  install  button.  After the installation is completed, close the Board Manager window.  Select your CT-ARM board from Tools   Board menu.", 
            "title": "Instructions"
        }, 
        {
            "location": "/How_to_Install/#using-git-version", 
            "text": "This is the suggested installation method for contributors and library\ndevelopers.", 
            "title": "Using git version"
        }, 
        {
            "location": "/How_to_Install/#prerequisites_1", 
            "text": "Arduino 1.6.7 (or newer, if you know what you are doing)  Python 2.7  git  terminal, console, or command prompt (depending on you OS)  Internet connection", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/How_to_Install/#instructions_1", 
            "text": "Open the console and go to Arduino directory. This can be either your\n    sketchbook  directory (usually  Documents /Arduino ), or the\n   directory of Arduino application itself, the choice is up to you.  Clone this repository into hardware/cytron_arm/ct-arm directory.\n   Alternatively, clone it elsewhere and create a symlink, if your OS\n   supports them.   cd hardware\nmkdir -p cytron_arm\ncd cytron_arm\ngit clone https://github.com/CytronTechnologies/CT-ARM.git ct-arm  You should end up with the following directory structure: Arduino\n|\n--- hardware\n   |\n   --- cytron_arm\n       |\n       --- CT-ARM\n           |\n           --- cores\n           --- docs\n           --- libraries\n           --- tools\n           --- package\n           --- system\n           --- variants\n           --- platform.txt\n           --- programmers.txt\n           --- README.md\n           --- boards.txt\n           --- LICENSE.md    Download binary tools   cd ct-arm/tools\npython get.py   Restart Arduino", 
            "title": "Instructions"
        }, 
        {
            "location": "/Getting_Started/", 
            "text": "You can refer to our \ntutorial\n to get started with CT-ARM!", 
            "title": "Getting Started"
        }, 
        {
            "location": "/libraries/Analog/", 
            "text": "analogRead()\n\n\nDescription\n\n\nReads the value from the specified analog pin. CT-ARM contains 6 channel 12-bit analog to digital converter. However by default, it gives 10 bit resolution, a.k.a it will map input voltages between 0 and 5 volts into integer values between 0 and 1023. This yields a resolution between readings of: 5 volts / 1024 units or, .0049 volts (4.9 mV) per unit. To change the resolution, please refer to \nanalogReadResolution()\n.\n\n\nSyntax\n\n\nanalogRead(pin)\n\n\nParameters\n\n\n\n\npin: the number of the analog input pin to read from 0 to 5\n\n\n\n\nReturns\n\n\nint (0 to 1023)\n\n\n\n\nNote\n\n\nIf the analog input pin is not connected to anything, the value returned by analogRead() will fluctuate based on a number of factors (e.g. the values of the other analog inputs, how close your hand is to the board, etc.).\n\n\n\n\nExample\n\n\nint\n \nanalogPin\n \n=\n \n3\n;\n     \n// potentiometer wiper (middle terminal) connected to analog pin 3\n\n                       \n// outside leads to ground and +5V\n\n\nint\n \nval\n \n=\n \n0\n;\n           \n// variable to store the value read\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n          \n//  setup serial\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nval\n \n=\n \nanalogRead\n(\nanalogPin\n);\n    \n// read the input pin\n\n  \nSerial\n.\nprintln\n(\nval\n);\n             \n// debug value\n\n\n}\n\n\n\n\n\n\nanalogWrite()\n\n\nDescription\n\n\nWrites an analog value (PWM wave) to a pin. Can be used to light a LED at varying brightnesses or drive a motor at various speeds. After a call to analogWrite(), the pin will generate a steady square wave of the specified duty cycle until the next call to analogWrite() (or a call to digitalRead() or digitalWrite() on the same pin). \n\n\nOn CT-ARM, this function works on all 16 I/O pins (analog and digital pins).\n\n\nYou do not need to call pinMode() to set the pin as an output before calling analogWrite().\n\n\nThe analogWrite function has nothing to do with the analog pins or the analogRead function.\n\n\nSyntax\n\n\nanalogWrite(pin, value)\n\n\nParameters\n\n\n\n\n\n\npin: the pin to write to.\n\n\n\n\n\n\nvalue: the duty cycle: between 0 (always off) and 255 (always on).\n\n\n\n\n\n\nReturns\n\n\nNone\n\n\nExample\n\n\nint\n \nledPin\n \n=\n \n13\n;\n      \n// built-in LED\n\n\nint\n \nanalogPin\n \n=\n \n3\n;\n   \n// potentiometer connected to analog pin 3\n\n\nint\n \nval\n \n=\n \n0\n;\n         \n// variable to store the read value\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \npinMode\n(\nledPin\n,\n \nOUTPUT\n);\n   \n// sets the pin as output\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nval\n \n=\n \nanalogRead\n(\nanalogPin\n);\n   \n// read the input pin\n\n  \nanalogWrite\n(\nledPin\n,\n \nval\n \n/\n \n4\n);\n  \n// analogRead values go from 0 to 1023, analogWrite values from 0 to 255\n\n\n}\n\n\n\n\n\n\nanalogReadResolution()\n\n\nDescription\n\n\nSets the size (in bits) of the value returned by analogRead(). It defaults to 10 bits (returns values between 0-1023).\n\n\nCT-ARM has 12-bit ADC capabilities that can be accessed by changing the resolution to 12. This will return values from analogRead() between 0 and 4095.\n\n\nSyntax\n\n\nanalogReadResolution(bits)\n\n\nParameters\n\n\n\n\nbits: determines the resolution (in bits) of the value returned by analogRead() function. You can set this 1 and 12.\n\n\n\n\nReturns\n\n\nNone\n\n\n\n\nNote\n\n\nIf you set the analogReadResolution() value to a value lower than your board's capabilities, the extra least significant bits read from the ADC will be discarded.\n\n\n\n\nExample\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \n// open a serial connection\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n \n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \n// read the input on A0 at default resolution (10 bits)\n\n  \n// and send it out the serial connection \n\n  \nanalogReadResolution\n(\n10\n);\n\n  \nSerial\n.\nprint\n(\nADC 10-bit (default) : \n);\n\n  \nSerial\n.\nprint\n(\nanalogRead\n(\nA0\n));\n\n\n  \n// change the resolution to 12 bits and read A0\n\n  \nanalogReadResolution\n(\n12\n);\n\n  \nSerial\n.\nprint\n(\n, 12-bit : \n);\n\n  \nSerial\n.\nprint\n(\nanalogRead\n(\nA0\n));\n\n\n  \n// change the resolution to 8 bits and read A0\n\n  \nanalogReadResolution\n(\n8\n);\n\n  \nSerial\n.\nprint\n(\n, 8-bit : \n);\n\n  \nSerial\n.\nprintln\n(\nanalogRead\n(\nA0\n));\n\n\n  \n// a little delay to not hog serial monitor\n\n  \ndelay\n(\n100\n);\n\n\n}\n\n\n\n\n\n\nanalogWriteResolution()\n\n\nDescription\n\n\nSets the resolution of the analogWrite() function. It defaults to 8 bits (values between 0-255) \n\n\nSyntax\n\n\nanalogWriteResolution(bits)\n\n\nParameters\n\n\n\n\nbits: determines the resolution (in bits) of the values used in the analogWrite() function.\n\n\n\n\nReturns\n\n\nNone\n\n\nExample\n\n\nvoid\n \nsetup\n(){\n\n  \n// open a serial connection\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n \n  \n// make our digital pin an output\n\n  \npinMode\n(\n11\n,\n \nOUTPUT\n);\n\n  \npinMode\n(\n12\n,\n \nOUTPUT\n);\n\n  \npinMode\n(\n13\n,\n \nOUTPUT\n);\n\n\n}\n\n\n\nvoid\n \nloop\n(){\n\n  \n// read the input on A0 and map it to a PWM pin\n\n  \n// with an attached LED\n\n  \nint\n \nsensorVal\n \n=\n \nanalogRead\n(\nA0\n);\n\n  \nSerial\n.\nprint\n(\nAnalog Read) : \n);\n\n  \nSerial\n.\nprint\n(\nsensorVal\n);\n\n\n  \n// the default PWM resolution\n\n  \nanalogWriteResolution\n(\n8\n);\n\n  \nanalogWrite\n(\n11\n,\n \nmap\n(\nsensorVal\n,\n \n0\n,\n \n1023\n,\n \n0\n \n,\n255\n));\n\n  \nSerial\n.\nprint\n(\n , 8-bit PWM value : \n);\n\n  \nSerial\n.\nprint\n(\nmap\n(\nsensorVal\n,\n \n0\n,\n \n1023\n,\n \n0\n \n,\n255\n));\n\n\n  \n// change the PWM resolution to 12 bits\n\n  \n// the full 12 bit resolution is only supported\n\n  \n// on the Due\n\n  \nanalogWriteResolution\n(\n12\n);\n\n  \nanalogWrite\n(\n12\n,\n \nmap\n(\nsensorVal\n,\n \n0\n,\n \n1023\n,\n \n0\n,\n \n4095\n));\n\n  \nSerial\n.\nprint\n(\n , 12-bit PWM value : \n);\n\n  \nSerial\n.\nprint\n(\nmap\n(\nsensorVal\n,\n \n0\n,\n \n1023\n,\n \n0\n,\n \n4095\n));\n\n\n  \n// change the PWM resolution to 4 bits\n\n  \nanalogWriteResolution\n(\n4\n);\n\n  \nanalogWrite\n(\n13\n,\n \nmap\n(\nsensorVal\n,\n \n0\n,\n \n1023\n,\n \n0\n,\n \n15\n));\n\n  \nSerial\n.\nprint\n(\n, 4-bit PWM value : \n);\n\n  \nSerial\n.\nprintln\n(\nmap\n(\nsensorVal\n,\n \n0\n,\n \n1023\n,\n \n0\n,\n \n15\n));\n\n\n  \ndelay\n(\n5\n);", 
            "title": "Analog"
        }, 
        {
            "location": "/libraries/Analog/#analogread", 
            "text": "Description  Reads the value from the specified analog pin. CT-ARM contains 6 channel 12-bit analog to digital converter. However by default, it gives 10 bit resolution, a.k.a it will map input voltages between 0 and 5 volts into integer values between 0 and 1023. This yields a resolution between readings of: 5 volts / 1024 units or, .0049 volts (4.9 mV) per unit. To change the resolution, please refer to  analogReadResolution() .  Syntax  analogRead(pin)  Parameters   pin: the number of the analog input pin to read from 0 to 5   Returns  int (0 to 1023)   Note  If the analog input pin is not connected to anything, the value returned by analogRead() will fluctuate based on a number of factors (e.g. the values of the other analog inputs, how close your hand is to the board, etc.).   Example  int   analogPin   =   3 ;       // potentiometer wiper (middle terminal) connected to analog pin 3 \n                        // outside leads to ground and +5V  int   val   =   0 ;             // variable to store the value read  void   setup ()  { \n   Serial . begin ( 9600 );            //  setup serial  }  void   loop ()  { \n   val   =   analogRead ( analogPin );      // read the input pin \n   Serial . println ( val );               // debug value  }", 
            "title": "analogRead()"
        }, 
        {
            "location": "/libraries/Analog/#analogwrite", 
            "text": "Description  Writes an analog value (PWM wave) to a pin. Can be used to light a LED at varying brightnesses or drive a motor at various speeds. After a call to analogWrite(), the pin will generate a steady square wave of the specified duty cycle until the next call to analogWrite() (or a call to digitalRead() or digitalWrite() on the same pin).   On CT-ARM, this function works on all 16 I/O pins (analog and digital pins).  You do not need to call pinMode() to set the pin as an output before calling analogWrite().  The analogWrite function has nothing to do with the analog pins or the analogRead function.  Syntax  analogWrite(pin, value)  Parameters    pin: the pin to write to.    value: the duty cycle: between 0 (always off) and 255 (always on).    Returns  None  Example  int   ledPin   =   13 ;        // built-in LED  int   analogPin   =   3 ;     // potentiometer connected to analog pin 3  int   val   =   0 ;           // variable to store the read value  void   setup ()  { \n   pinMode ( ledPin ,   OUTPUT );     // sets the pin as output  }  void   loop ()  { \n   val   =   analogRead ( analogPin );     // read the input pin \n   analogWrite ( ledPin ,   val   /   4 );    // analogRead values go from 0 to 1023, analogWrite values from 0 to 255  }", 
            "title": "analogWrite()"
        }, 
        {
            "location": "/libraries/Analog/#analogreadresolution", 
            "text": "Description  Sets the size (in bits) of the value returned by analogRead(). It defaults to 10 bits (returns values between 0-1023).  CT-ARM has 12-bit ADC capabilities that can be accessed by changing the resolution to 12. This will return values from analogRead() between 0 and 4095.  Syntax  analogReadResolution(bits)  Parameters   bits: determines the resolution (in bits) of the value returned by analogRead() function. You can set this 1 and 12.   Returns  None   Note  If you set the analogReadResolution() value to a value lower than your board's capabilities, the extra least significant bits read from the ADC will be discarded.   Example  void   setup ()   { \n   // open a serial connection \n   Serial . begin ( 9600 );   }  void   loop ()   { \n   // read the input on A0 at default resolution (10 bits) \n   // and send it out the serial connection  \n   analogReadResolution ( 10 ); \n   Serial . print ( ADC 10-bit (default) :  ); \n   Serial . print ( analogRead ( A0 )); \n\n   // change the resolution to 12 bits and read A0 \n   analogReadResolution ( 12 ); \n   Serial . print ( , 12-bit :  ); \n   Serial . print ( analogRead ( A0 )); \n\n   // change the resolution to 8 bits and read A0 \n   analogReadResolution ( 8 ); \n   Serial . print ( , 8-bit :  ); \n   Serial . println ( analogRead ( A0 )); \n\n   // a little delay to not hog serial monitor \n   delay ( 100 );  }", 
            "title": "analogReadResolution()"
        }, 
        {
            "location": "/libraries/Analog/#analogwriteresolution", 
            "text": "Description  Sets the resolution of the analogWrite() function. It defaults to 8 bits (values between 0-255)   Syntax  analogWriteResolution(bits)  Parameters   bits: determines the resolution (in bits) of the values used in the analogWrite() function.   Returns  None  Example  void   setup (){ \n   // open a serial connection \n   Serial . begin ( 9600 );  \n   // make our digital pin an output \n   pinMode ( 11 ,   OUTPUT ); \n   pinMode ( 12 ,   OUTPUT ); \n   pinMode ( 13 ,   OUTPUT );  }  void   loop (){ \n   // read the input on A0 and map it to a PWM pin \n   // with an attached LED \n   int   sensorVal   =   analogRead ( A0 ); \n   Serial . print ( Analog Read) :  ); \n   Serial . print ( sensorVal ); \n\n   // the default PWM resolution \n   analogWriteResolution ( 8 ); \n   analogWrite ( 11 ,   map ( sensorVal ,   0 ,   1023 ,   0   , 255 )); \n   Serial . print (  , 8-bit PWM value :  ); \n   Serial . print ( map ( sensorVal ,   0 ,   1023 ,   0   , 255 )); \n\n   // change the PWM resolution to 12 bits \n   // the full 12 bit resolution is only supported \n   // on the Due \n   analogWriteResolution ( 12 ); \n   analogWrite ( 12 ,   map ( sensorVal ,   0 ,   1023 ,   0 ,   4095 )); \n   Serial . print (  , 12-bit PWM value :  ); \n   Serial . print ( map ( sensorVal ,   0 ,   1023 ,   0 ,   4095 )); \n\n   // change the PWM resolution to 4 bits \n   analogWriteResolution ( 4 ); \n   analogWrite ( 13 ,   map ( sensorVal ,   0 ,   1023 ,   0 ,   15 )); \n   Serial . print ( , 4-bit PWM value :  ); \n   Serial . println ( map ( sensorVal ,   0 ,   1023 ,   0 ,   15 )); \n\n   delay ( 5 );", 
            "title": "analogWriteResolution()"
        }, 
        {
            "location": "/libraries/Digital/", 
            "text": "Note\n\n\nThe analog input pins can be used as digital pins, referred to as A0, A1, etc.\n\n\n\n\npinMode()\n\n\nDescription\n\n\nConfigures the specified pin to behave either as an input or an output.\n\n\nSyntax\n\n\npinMode(pin, mode)\n\n\nParameters\n\n\n\n\n\n\npin: the number of the pin whose mode you wish to set\n\n\n\n\n\n\nmode: \nINPUT\n, \nOUTPUT\n, or \nINPUT_PULLUP\n. \n\n\n\n\n\n\nReturns\n\n\nNone\n\n\nExample\n\n\nint\n \nledPin\n \n=\n \n13\n;\n                 \n// LED connected to digital pin 13\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \npinMode\n(\nledPin\n,\n \nOUTPUT\n);\n      \n// sets the digital pin as output\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \ndigitalWrite\n(\nledPin\n,\n \nHIGH\n);\n   \n// sets the LED on\n\n  \ndelay\n(\n1000\n);\n                  \n// waits for a second\n\n  \ndigitalWrite\n(\nledPin\n,\n \nLOW\n);\n    \n// sets the LED off\n\n  \ndelay\n(\n1000\n);\n                  \n// waits for a second\n\n\n}\n\n\n\n\n\n\ndigitalWrite()\n\n\nDescription\n\n\nWrite a HIGH or a LOW value to a digital pin.\n\n\nIf the pin has been configured as an OUTPUT with pinMode(), its voltage will be set to the corresponding value: 5V for HIGH, 0V (ground) for LOW.\n\n\nSyntax\n\n\ndigitalWrite(pin, value)\n\n\nParameters\n\n\n\n\n\n\npin: the pin number\n\n\n\n\n\n\nvalue: \nHIGH\n or \nLOW\n\n\n\n\n\n\nReturns\n\n\nNone\n\n\nExample\n\n\nint\n \nledPin\n \n=\n \n13\n;\n                 \n// LED connected to digital pin 13\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \npinMode\n(\nledPin\n,\n \nOUTPUT\n);\n      \n// sets the digital pin as output\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \ndigitalWrite\n(\nledPin\n,\n \nHIGH\n);\n   \n// sets the LED on\n\n  \ndelay\n(\n1000\n);\n                  \n// waits for a second\n\n  \ndigitalWrite\n(\nledPin\n,\n \nLOW\n);\n    \n// sets the LED off\n\n  \ndelay\n(\n1000\n);\n                  \n// waits for a second\n\n\n}\n\n\n\n\nSets pin 13 to HIGH, makes a one-second-long delay, and sets the pin back to LOW.\n\n\ndigitalRead()\n\n\nDescription\n\n\nReads the value from a specified digital pin, either HIGH or LOW.\n\n\nSyntax\n\n\ndigitalRead(pin)\n\n\nParameters\n\n\n\n\npin: the number of the digital pin you want to read (int)\n\n\n\n\nReturns\n\n\nHIGH or LOW\n\n\nExample\n\n\nSets pin 13 to the same value as pin 7, declared as an input.\n\n\nint\n \nledPin\n \n=\n \n13\n;\n \n// LED connected to digital pin 13\n\n\nint\n \ninPin\n \n=\n \n7\n;\n   \n// pushbutton connected to digital pin 7\n\n\nint\n \nval\n \n=\n \n0\n;\n     \n// variable to store the read value\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \npinMode\n(\nledPin\n,\n \nOUTPUT\n);\n      \n// sets the digital pin 13 as output\n\n  \npinMode\n(\ninPin\n,\n \nINPUT\n);\n      \n// sets the digital pin 7 as input\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nval\n \n=\n \ndigitalRead\n(\ninPin\n);\n   \n// read the input pin\n\n  \ndigitalWrite\n(\nledPin\n,\n \nval\n);\n    \n// sets the LED to the button\ns value\n\n\n}\n\n\n\n\n\n\n\n\nNote\n\n\nIf the pin isn't connected to anything, digitalRead() can return either HIGH or LOW (and this can change randomly).", 
            "title": "Digital"
        }, 
        {
            "location": "/libraries/Digital/#pinmode", 
            "text": "Description  Configures the specified pin to behave either as an input or an output.  Syntax  pinMode(pin, mode)  Parameters    pin: the number of the pin whose mode you wish to set    mode:  INPUT ,  OUTPUT , or  INPUT_PULLUP .     Returns  None  Example  int   ledPin   =   13 ;                   // LED connected to digital pin 13  void   setup ()  { \n   pinMode ( ledPin ,   OUTPUT );        // sets the digital pin as output  }  void   loop ()  { \n   digitalWrite ( ledPin ,   HIGH );     // sets the LED on \n   delay ( 1000 );                    // waits for a second \n   digitalWrite ( ledPin ,   LOW );      // sets the LED off \n   delay ( 1000 );                    // waits for a second  }", 
            "title": "pinMode()"
        }, 
        {
            "location": "/libraries/Digital/#digitalwrite", 
            "text": "Description  Write a HIGH or a LOW value to a digital pin.  If the pin has been configured as an OUTPUT with pinMode(), its voltage will be set to the corresponding value: 5V for HIGH, 0V (ground) for LOW.  Syntax  digitalWrite(pin, value)  Parameters    pin: the pin number    value:  HIGH  or  LOW    Returns  None  Example  int   ledPin   =   13 ;                   // LED connected to digital pin 13  void   setup ()  { \n   pinMode ( ledPin ,   OUTPUT );        // sets the digital pin as output  }  void   loop ()  { \n   digitalWrite ( ledPin ,   HIGH );     // sets the LED on \n   delay ( 1000 );                    // waits for a second \n   digitalWrite ( ledPin ,   LOW );      // sets the LED off \n   delay ( 1000 );                    // waits for a second  }  \n\nSets pin 13 to HIGH, makes a one-second-long delay, and sets the pin back to LOW.", 
            "title": "digitalWrite()"
        }, 
        {
            "location": "/libraries/Digital/#digitalread", 
            "text": "Description  Reads the value from a specified digital pin, either HIGH or LOW.  Syntax  digitalRead(pin)  Parameters   pin: the number of the digital pin you want to read (int)   Returns  HIGH or LOW  Example  Sets pin 13 to the same value as pin 7, declared as an input.  int   ledPin   =   13 ;   // LED connected to digital pin 13  int   inPin   =   7 ;     // pushbutton connected to digital pin 7  int   val   =   0 ;       // variable to store the read value  void   setup ()  { \n   pinMode ( ledPin ,   OUTPUT );        // sets the digital pin 13 as output \n   pinMode ( inPin ,   INPUT );        // sets the digital pin 7 as input  }  void   loop ()  { \n   val   =   digitalRead ( inPin );     // read the input pin \n   digitalWrite ( ledPin ,   val );      // sets the LED to the button s value  }    Note  If the pin isn't connected to anything, digitalRead() can return either HIGH or LOW (and this can change randomly).", 
            "title": "digitalRead()"
        }, 
        {
            "location": "/libraries/EEPROM/", 
            "text": "EEPROM - Emulated\n\n\nCT-ARM does not have actual EEPROM, instead it has data flash memory which size is up to 4KB. Here we are using EEPROM-like library to gain read/write access to the data flash. There are total of 1024 EEPROM addresses, each address is able to store up to 4 bytes.\n\n\nread()\n\n\nDescription\n\n\nReads value (in form of 4 bytes) from the EEPROM. Locations that have never been written to have the value of 0xFFFF.\n\n\nSyntax\n\n\nEEPROM.read(address)\n\n\nParameters\n\n\n\n\naddress: the location to read from, starting from 0 (int) to 1023\n\n\n\n\nReturns\n\n\nthe value stored in that location (4 bytes)\n\n\nExample\n\n\n#include\n \nEEPROM.h\n\n\n\nint\n \na\n \n=\n \n0\n;\n\n\nint\n \nvalue\n;\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nvalue\n \n=\n \nEEPROM\n.\nread\n(\na\n);\n\n\n  \nSerial\n.\nprint\n(\na\n);\n\n  \nSerial\n.\nprint\n(\n\\t\n);\n\n  \nSerial\n.\nprint\n(\nvalue\n);\n\n  \nSerial\n.\nprintln\n();\n\n\n  \na\n \n=\n \na\n \n+\n \n1\n;\n\n\n  \nif\n \n(\na\n \n==\n \n1024\n)\n\n    \na\n \n=\n \n0\n;\n\n\n  \ndelay\n(\n500\n);\n\n\n}\n\n\n\n\n\n\nwrite()\n\n\nDescription\n\n\nWrite value to the EEPROM.\n\n\nSyntax\n\n\nEEPROM.write(address, value)\n\n\nParameters\n\n\n\n\n\n\naddress: the location to write to, starting from 0 (int) to 1023\n\n\n\n\n\n\nvalue: the value to write, from 0 to \n\\(2^{32}\\)\n (4 bytes)\n\n\n\n\n\n\nReturns\n\n\nNone\n\n\n\n\nWarning\n\n\nThe data flash memory has a specified life of write/erase cycles, so you may need to be careful about how often you write to it.\n\n\n\n\nExample\n\n\n#include\n \nEEPROM.h\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \n255\n;\n \ni\n++\n)\n\n    \nEEPROM\n.\nwrite\n(\ni\n,\n \ni\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n\n}\n\n\n\n\n\n\nupdate()\n\n\nDescription\n\n\nWrite value to the EEPROM. The value is written only if differs from the one already saved at the same address.\n\n\nSyntax\n\n\nEEPROM.update(address, value)\n\n\nParameters\n\n\n\n\n\n\naddress: the location to write to, starting from 0 (int) to 1023\n\n\n\n\n\n\nvalue: the value to write, from 0 to \n\\(2^{32}\\)\n (4 bytes)\n\n\n\n\n\n\nReturns\n\n\nNone\n\n\n\n\nWarning\n\n\nThe data flash memory has a specified life of write/erase cycles, using this function instead of \nwrite()\n can save cycles if the written data does not change often.\n\n\n\n\nExample\n\n\n#include\n \nEEPROM.h\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \n255\n;\n \ni\n++\n)\n \n{\n\n    \n// this performs as EEPROM.write(i, i)\n\n    \nEEPROM\n.\nupdate\n(\ni\n,\n \ni\n);\n\n  \n}\n\n  \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \n255\n;\n \ni\n++\n)\n \n{\n\n    \n// write value \n12\n to cell 3 only the first time\n\n    \n// will not write the cell the remaining 254 times\n\n    \nEEPROM\n.\nupdate\n(\n3\n,\n \n12\n);\n\n  \n}\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n\n}\n\n\n\n\n\n\nget()\n\n\nDescription\n\n\nRead any data type or object from the EEPROM.\n\n\nSyntax\n\n\nEEPROM.get(address, data)\n\n\nParameters\n\n\n\n\n\n\naddress: the location to read from, starting from 0 (int)\n\n\n\n\n\n\ndata: the data to read, can be a primitive type (eg. float) or a custom struct\n\n\n\n\n\n\nReturns\n\n\nA reference to the data passed in\n\n\nExample\n\n\n#include\n \nEEPROM.h\n\n\n\nstruct\n \nMyObject\n{\n\n  \nfloat\n \nfield1\n;\n\n  \nbyte\n \nfield2\n;\n\n  \nchar\n \nname\n[\n10\n];\n\n\n};\n\n\n\nvoid\n \nsetup\n(){\n\n\n  \nfloat\n \nf\n \n=\n \n0.00f\n;\n   \n//Variable to store data read from EEPROM.\n\n  \nint\n \neeAddress\n \n=\n \n0\n;\n \n//EEPROM address to start reading from\n\n\n  \nSerial\n.\nbegin\n(\n \n9600\n \n);\n\n  \nwhile\n \n(\n!\nSerial\n)\n \n{\n\n    \n;\n \n// wait for serial port to connect. Needed for Leonardo only\n\n  \n}\n\n  \nSerial\n.\nprint\n(\n \nRead float from EEPROM: \n \n);\n\n\n  \n//Get the float data from the EEPROM at position \neeAddress\n\n  \nEEPROM\n.\nget\n(\n \neeAddress\n,\n \nf\n \n);\n\n  \nSerial\n.\nprintln\n(\n \nf\n,\n \n3\n \n);\n  \n//This may print \novf, nan\n if the data inside the EEPROM is not a valid float.\n\n\n  \n// get() can be used with custom structures too. \n\n  \neeAddress\n \n=\n \nsizeof\n(\nfloat\n);\n \n//Move address to the next byte after float \nf\n.\n\n  \nMyObject\n \ncustomVar\n;\n \n//Variable to store custom object read from EEPROM.\n\n  \nEEPROM\n.\nget\n(\n \neeAddress\n,\n \ncustomVar\n \n);\n\n\n  \nSerial\n.\nprintln\n(\n \nRead custom object from EEPROM: \n \n);\n\n  \nSerial\n.\nprintln\n(\n \ncustomVar\n.\nfield1\n \n);\n\n  \nSerial\n.\nprintln\n(\n \ncustomVar\n.\nfield2\n \n);\n\n  \nSerial\n.\nprintln\n(\n \ncustomVar\n.\nname\n \n);\n\n\n}\n\n\n\nvoid\n \nloop\n(){\n \n/* Empty loop */\n \n}\n\n\n\n\n\n\nput()\n\n\nDescription\n\n\nWrite any data type or object to the EEPROM.\n\n\nSyntax\n\n\nEEPROM.put(address, data)\n\n\nParameters\n\n\n\n\n\n\naddress: the location to write to, starting from 0 (int)\n\n\n\n\n\n\ndata: the data to write, can be a primitive type (eg. float) or a custom struct\n\n\n\n\n\n\nReturns\n\n\nA reference to the data passed in\n\n\n\n\nNote\n\n\nThis function uses EEPROM.update() to perform the write, so does not rewrites the value if it didn't change.\n\n\n\n\nExample\n\n\n#include\n \nEEPROM.h\n\n\n\nstruct\n \nMyObject\n \n{\n\n  \nfloat\n \nfield1\n;\n\n  \nbyte\n \nfield2\n;\n\n  \nchar\n \nname\n[\n10\n];\n\n\n};\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n  \nwhile\n \n(\n!\nSerial\n)\n \n{\n\n    \n;\n \n// wait for serial port to connect. Needed for native USB port only\n\n  \n}\n\n\n  \nfloat\n \nf\n \n=\n \n123.456f\n;\n  \n//Variable to store in EEPROM.\n\n  \nint\n \neeAddress\n \n=\n \n0\n;\n   \n//Location we want the data to be put.\n\n\n\n  \n//One simple call, with the address first and the object second.\n\n  \nEEPROM\n.\nput\n(\neeAddress\n,\n \nf\n);\n\n\n  \nSerial\n.\nprintln\n(\nWritten float data type!\n);\n\n\n  \n/** Put is designed for use with custom structures also. **/\n\n\n  \n//Data to store.\n\n  \nMyObject\n \ncustomVar\n \n=\n \n{\n\n    \n3.14f\n,\n\n    \n65\n,\n\n    \nWorking!\n\n  \n};\n\n\n  \neeAddress\n \n+=\n \nsizeof\n(\nfloat\n);\n \n//Move address to the next byte after float \nf\n.\n\n\n  \nEEPROM\n.\nput\n(\neeAddress\n,\n \ncustomVar\n);\n\n  \nSerial\n.\nprint\n(\nWritten custom data type! \n\\n\\n\nView the example sketch eeprom_get to see how you can retrieve the values!\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \n/* Empty loop */\n\n\n}\n\n\n\n\n\n\neraseAddressBlock()\n\n\nfastWrite()", 
            "title": "EEPROM"
        }, 
        {
            "location": "/libraries/EEPROM/#eeprom-emulated", 
            "text": "CT-ARM does not have actual EEPROM, instead it has data flash memory which size is up to 4KB. Here we are using EEPROM-like library to gain read/write access to the data flash. There are total of 1024 EEPROM addresses, each address is able to store up to 4 bytes.", 
            "title": "EEPROM - Emulated"
        }, 
        {
            "location": "/libraries/EEPROM/#read", 
            "text": "Description  Reads value (in form of 4 bytes) from the EEPROM. Locations that have never been written to have the value of 0xFFFF.  Syntax  EEPROM.read(address)  Parameters   address: the location to read from, starting from 0 (int) to 1023   Returns  the value stored in that location (4 bytes)  Example  #include   EEPROM.h  int   a   =   0 ;  int   value ;  void   setup ()  { \n   Serial . begin ( 9600 );  }  void   loop ()  { \n   value   =   EEPROM . read ( a ); \n\n   Serial . print ( a ); \n   Serial . print ( \\t ); \n   Serial . print ( value ); \n   Serial . println (); \n\n   a   =   a   +   1 ; \n\n   if   ( a   ==   1024 ) \n     a   =   0 ; \n\n   delay ( 500 );  }", 
            "title": "read()"
        }, 
        {
            "location": "/libraries/EEPROM/#write", 
            "text": "Description  Write value to the EEPROM.  Syntax  EEPROM.write(address, value)  Parameters    address: the location to write to, starting from 0 (int) to 1023    value: the value to write, from 0 to  \\(2^{32}\\)  (4 bytes)    Returns  None   Warning  The data flash memory has a specified life of write/erase cycles, so you may need to be careful about how often you write to it.   Example  #include   EEPROM.h  void   setup ()  { \n   for   ( int   i   =   0 ;   i     255 ;   i ++ ) \n     EEPROM . write ( i ,   i );  }  void   loop ()  {  }", 
            "title": "write()"
        }, 
        {
            "location": "/libraries/EEPROM/#update", 
            "text": "Description  Write value to the EEPROM. The value is written only if differs from the one already saved at the same address.  Syntax  EEPROM.update(address, value)  Parameters    address: the location to write to, starting from 0 (int) to 1023    value: the value to write, from 0 to  \\(2^{32}\\)  (4 bytes)    Returns  None   Warning  The data flash memory has a specified life of write/erase cycles, using this function instead of  write()  can save cycles if the written data does not change often.   Example  #include   EEPROM.h  void   setup ()  { \n   for   ( int   i   =   0 ;   i     255 ;   i ++ )   { \n     // this performs as EEPROM.write(i, i) \n     EEPROM . update ( i ,   i ); \n   } \n   for   ( int   i   =   0 ;   i     255 ;   i ++ )   { \n     // write value  12  to cell 3 only the first time \n     // will not write the cell the remaining 254 times \n     EEPROM . update ( 3 ,   12 ); \n   }  }  void   loop ()  {  }", 
            "title": "update()"
        }, 
        {
            "location": "/libraries/EEPROM/#get", 
            "text": "Description  Read any data type or object from the EEPROM.  Syntax  EEPROM.get(address, data)  Parameters    address: the location to read from, starting from 0 (int)    data: the data to read, can be a primitive type (eg. float) or a custom struct    Returns  A reference to the data passed in  Example  #include   EEPROM.h  struct   MyObject { \n   float   field1 ; \n   byte   field2 ; \n   char   name [ 10 ];  };  void   setup (){ \n\n   float   f   =   0.00f ;     //Variable to store data read from EEPROM. \n   int   eeAddress   =   0 ;   //EEPROM address to start reading from \n\n   Serial . begin (   9600   ); \n   while   ( ! Serial )   { \n     ;   // wait for serial port to connect. Needed for Leonardo only \n   } \n   Serial . print (   Read float from EEPROM:    ); \n\n   //Get the float data from the EEPROM at position  eeAddress \n   EEPROM . get (   eeAddress ,   f   ); \n   Serial . println (   f ,   3   );    //This may print  ovf, nan  if the data inside the EEPROM is not a valid float. \n\n   // get() can be used with custom structures too.  \n   eeAddress   =   sizeof ( float );   //Move address to the next byte after float  f . \n   MyObject   customVar ;   //Variable to store custom object read from EEPROM. \n   EEPROM . get (   eeAddress ,   customVar   ); \n\n   Serial . println (   Read custom object from EEPROM:    ); \n   Serial . println (   customVar . field1   ); \n   Serial . println (   customVar . field2   ); \n   Serial . println (   customVar . name   );  }  void   loop (){   /* Empty loop */   }", 
            "title": "get()"
        }, 
        {
            "location": "/libraries/EEPROM/#put", 
            "text": "Description  Write any data type or object to the EEPROM.  Syntax  EEPROM.put(address, data)  Parameters    address: the location to write to, starting from 0 (int)    data: the data to write, can be a primitive type (eg. float) or a custom struct    Returns  A reference to the data passed in   Note  This function uses EEPROM.update() to perform the write, so does not rewrites the value if it didn't change.   Example  #include   EEPROM.h  struct   MyObject   { \n   float   field1 ; \n   byte   field2 ; \n   char   name [ 10 ];  };  void   setup ()   { \n\n   Serial . begin ( 9600 ); \n   while   ( ! Serial )   { \n     ;   // wait for serial port to connect. Needed for native USB port only \n   } \n\n   float   f   =   123.456f ;    //Variable to store in EEPROM. \n   int   eeAddress   =   0 ;     //Location we want the data to be put. \n\n\n   //One simple call, with the address first and the object second. \n   EEPROM . put ( eeAddress ,   f ); \n\n   Serial . println ( Written float data type! ); \n\n   /** Put is designed for use with custom structures also. **/ \n\n   //Data to store. \n   MyObject   customVar   =   { \n     3.14f , \n     65 , \n     Working! \n   }; \n\n   eeAddress   +=   sizeof ( float );   //Move address to the next byte after float  f . \n\n   EEPROM . put ( eeAddress ,   customVar ); \n   Serial . print ( Written custom data type!  \\n\\n View the example sketch eeprom_get to see how you can retrieve the values! );  }  void   loop ()   { \n   /* Empty loop */  }", 
            "title": "put()"
        }, 
        {
            "location": "/libraries/EEPROM/#eraseaddressblock", 
            "text": "", 
            "title": "eraseAddressBlock()"
        }, 
        {
            "location": "/libraries/EEPROM/#fastwrite", 
            "text": "", 
            "title": "fastWrite()"
        }, 
        {
            "location": "/libraries/Interrupt/", 
            "text": "attachInterrupt()\n\n\nDescription\n\n\n\n\nDigital Pins With Interrupts\n\n\n\n\nAll I/O pins on CT-ARM can be used as external interrupts. You can place pin number as first parameter of attachInterrupt. For example, if you connect to pin 3, use 3 as first parameter to attachInterrupt.\n\n\n\n\nUsing Interrupts\n\n\n\n\nInterrupts are useful for making things happen automatically in microcontroller programs, and can help solve timing problems. Good tasks for using an interrupt may include reading a rotary encoder, or monitoring user input.\n\n\nIf you wanted to insure that a program always caught the pulses from a rotary encoder, so that it never misses a pulse, it would make it very tricky to write a program to do anything else, because the program would need to constantly poll the sensor lines for the encoder, in order to catch pulses when they occurred. Other sensors have a similar interface dynamic too, such as trying to read a sound sensor that is trying to catch a click, or an infrared slot sensor (photo-interrupter) trying to catch a coin drop. In all of these situations, using an interrupt can free the microcontroller to get some other work done while not missing the input.\n\n\n\n\nInterrupt Service Routines\n\n\n\n\nISRs are special kinds of functions that have some unique limitations most other functions do not have. An ISR cannot have any parameters, and they shouldn't return anything.\n\n\nGenerally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time, other interrupts will be executed after the current one finishes in an order that depends on the priority they have. millis() relies on interrupts to count, so it will never increment inside an ISR. Since delay() requires interrupts to work, it will not work if called inside an ISR. micros() works initially, but will start behaving erratically after 1-2 ms. delayMicroseconds() does not use any counter, so it will work as normal.\n\n\nTypically global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile.\n\n\nFor more information on interrupts, see \nNick Gammon's notes\n.\n\n\n\n\nWarning\n\n\nInside the attached function, delay() won't work and the value returned by millis() will not increment. Serial data received while in the function may be lost. You should declare as volatile any variables that you modify within the attached function.\n\n\n\n\nSyntax\n\n\nattachInterrupt(pin, ISR, mode)\n\n\nParameters\n\n\n\n\npin: the pin number\n\n\nISR: the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.\n\n\nmode: defines when the interrupt should be triggered. 3 constants are predefined as valid values:\n\n\nCHANGE\n to trigger the interrupt whenever the pin changes value\n\n\nRISING\n to trigger when the pin goes from low to high,\n\n\nFALLING\n for when the pin goes from high to low.\n\n\n\n\n\n\n\n\nReturns\n\n\nNone\n\n\nExample\n\n\nconst\n \nbyte\n \nledPin\n \n=\n \n13\n;\n\n\nconst\n \nbyte\n \ninterruptPin\n \n=\n \n2\n;\n\n\nvolatile\n \nbyte\n \nstate\n \n=\n \nLOW\n;\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \npinMode\n(\nledPin\n,\n \nOUTPUT\n);\n\n  \npinMode\n(\ninterruptPin\n,\n \nINPUT_PULLUP\n);\n\n  \nattachInterrupt\n(\ninterruptPin\n,\n \nblink\n,\n \nCHANGE\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \ndigitalWrite\n(\nledPin\n,\n \nstate\n);\n\n\n}\n\n\n\nvoid\n \nblink\n()\n \n{\n\n  \nstate\n \n=\n \n!\nstate\n;\n\n\n}\n\n\n\n\n\n\ndetachInterrupt()\n\n\nDescription\n\n\nTurns off the given interrupt.\n\n\nSyntax\n\n\ndetachInterrupt(pin)\n\n\nParameters\n\n\n\n\npin: the pin number of the interrupt to disable \n\n\n\n\nReturns\n\n\nNone\n\n\nExample\n\n\nconst\n \nbyte\n \nledPin\n \n=\n \n13\n;\n\n\nconst\n \nbyte\n \ninterruptPin\n \n=\n \n2\n;\n\n\nvolatile\n \nbyte\n \nstate\n \n=\n \nLOW\n;\n\n\nint\n \ncount\n \n=\n \n0\n;\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \npinMode\n(\nledPin\n,\n \nOUTPUT\n);\n\n  \npinMode\n(\ninterruptPin\n,\n \nINPUT_PULLUP\n);\n\n  \nattachInterrupt\n(\ninterruptPin\n,\n \nblink\n,\n \nCHANGE\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \ndigitalWrite\n(\nledPin\n,\n \nstate\n);\n\n  \nif\n(\ncount\n \n \n10\n){\n \n// stop the blinking after 10 times\n\n    \ndetachInterrupt\n(\ninterruptPin\n);\n\n  \n}\n\n\n}\n\n\n\nvoid\n \nblink\n()\n \n{\n\n  \nstate\n \n=\n \n!\nstate\n;\n\n  \nif\n(\nstate\n \n==\n \nHIGH\n){\n\n   \ncount\n++\n;\n\n  \n}\n\n\n}", 
            "title": "Interrupt"
        }, 
        {
            "location": "/libraries/Interrupt/#attachinterrupt", 
            "text": "Description   Digital Pins With Interrupts   All I/O pins on CT-ARM can be used as external interrupts. You can place pin number as first parameter of attachInterrupt. For example, if you connect to pin 3, use 3 as first parameter to attachInterrupt.   Using Interrupts   Interrupts are useful for making things happen automatically in microcontroller programs, and can help solve timing problems. Good tasks for using an interrupt may include reading a rotary encoder, or monitoring user input.  If you wanted to insure that a program always caught the pulses from a rotary encoder, so that it never misses a pulse, it would make it very tricky to write a program to do anything else, because the program would need to constantly poll the sensor lines for the encoder, in order to catch pulses when they occurred. Other sensors have a similar interface dynamic too, such as trying to read a sound sensor that is trying to catch a click, or an infrared slot sensor (photo-interrupter) trying to catch a coin drop. In all of these situations, using an interrupt can free the microcontroller to get some other work done while not missing the input.   Interrupt Service Routines   ISRs are special kinds of functions that have some unique limitations most other functions do not have. An ISR cannot have any parameters, and they shouldn't return anything.  Generally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time, other interrupts will be executed after the current one finishes in an order that depends on the priority they have. millis() relies on interrupts to count, so it will never increment inside an ISR. Since delay() requires interrupts to work, it will not work if called inside an ISR. micros() works initially, but will start behaving erratically after 1-2 ms. delayMicroseconds() does not use any counter, so it will work as normal.  Typically global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile.  For more information on interrupts, see  Nick Gammon's notes .   Warning  Inside the attached function, delay() won't work and the value returned by millis() will not increment. Serial data received while in the function may be lost. You should declare as volatile any variables that you modify within the attached function.   Syntax  attachInterrupt(pin, ISR, mode)  Parameters   pin: the pin number  ISR: the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.  mode: defines when the interrupt should be triggered. 3 constants are predefined as valid values:  CHANGE  to trigger the interrupt whenever the pin changes value  RISING  to trigger when the pin goes from low to high,  FALLING  for when the pin goes from high to low.     Returns  None  Example  const   byte   ledPin   =   13 ;  const   byte   interruptPin   =   2 ;  volatile   byte   state   =   LOW ;  void   setup ()   { \n   pinMode ( ledPin ,   OUTPUT ); \n   pinMode ( interruptPin ,   INPUT_PULLUP ); \n   attachInterrupt ( interruptPin ,   blink ,   CHANGE );  }  void   loop ()   { \n   digitalWrite ( ledPin ,   state );  }  void   blink ()   { \n   state   =   ! state ;  }", 
            "title": "attachInterrupt()"
        }, 
        {
            "location": "/libraries/Interrupt/#detachinterrupt", 
            "text": "Description  Turns off the given interrupt.  Syntax  detachInterrupt(pin)  Parameters   pin: the pin number of the interrupt to disable    Returns  None  Example  const   byte   ledPin   =   13 ;  const   byte   interruptPin   =   2 ;  volatile   byte   state   =   LOW ;  int   count   =   0 ;  void   setup ()   { \n   pinMode ( ledPin ,   OUTPUT ); \n   pinMode ( interruptPin ,   INPUT_PULLUP ); \n   attachInterrupt ( interruptPin ,   blink ,   CHANGE );  }  void   loop ()   { \n   digitalWrite ( ledPin ,   state ); \n   if ( count     10 ){   // stop the blinking after 10 times \n     detachInterrupt ( interruptPin ); \n   }  }  void   blink ()   { \n   state   =   ! state ; \n   if ( state   ==   HIGH ){ \n    count ++ ; \n   }  }", 
            "title": "detachInterrupt()"
        }, 
        {
            "location": "/libraries/Wire/", 
            "text": "Wire (I2C)\n\n\nThis library allows you to communicate with I2C / TWI devices. On CT-ARM board, the SDA (data line) and SCL (clock line) are on the pin headers close to the AREF pin. \n\n\n\n\nNote\n\n\n\n\nThere are both 7- and 8-bit versions of I2C addresses. 7 bits identify the device, and the eighth bit determines if it's being written to or read from. The Wire library uses 7 bit addresses throughout. If you have a datasheet or sample code that uses 8 bit address, you'll want to drop the low bit (i.e. shift the value one bit to the right), yielding an address between 0 and 127. However the addresses from 0 to 7 are not used because are reserved so the first address that can be used is 8. \n\n\nPull-up resistors\n are needed when connecting SDA/SCL pins. \n\n\n\n\n\n\nbegin()\n\n\nDescription\n\n\nInitiate the Wire library and join the I2C bus as a master or slave. This should normally be called only once.\n\n\nSyntax\n\n\nWire.begin()\n\n\nWire.begin(address)\n\n\nParameters\n\n\n\n\naddress: the 7-bit slave address (optional); if not specified, join the bus as a master.\n\n\n\n\nReturns\n\n\nNone\n\n\nExample\n\n\n#include\n \nWire.h\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nWire\n.\nbegin\n();\n\n\n}\n\n\n\nvoid\n \nloop\n(){\n \n/* Empty loop */\n \n}\n\n\n\n\n\n\nrequestFrom()\n\n\nDescription\n\n\nUsed by the master to request bytes from a slave device. The bytes may then be retrieved with the available() and read() functions.\n\n\nAs of Arduino 1.0.1, requestFrom() accepts a boolean argument changing its behavior for compatibility with certain I2C devices.\n\n\nIf true, requestFrom() sends a stop message after the request, releasing the I2C bus.\n\n\nIf false, requestFrom() sends a restart message after the request. The bus will not be released, which prevents another master device from requesting between messages. This allows one master device to send multiple requests while in control.\n\n\nThe default value is true.\n\n\nSyntax\n\n\nWire.requestFrom(address, quantity)\n\n\nWire.requestFrom(address, quantity, stop)\n\n\nParameters\n\n\n\n\n\n\naddress: the 7-bit address of the device to request bytes from\n\n\n\n\n\n\nquantity: the number of bytes to request\n\n\n\n\n\n\nstop : boolean. true will send a stop message after the request, releasing the bus. false will continually send a restart after the request, keeping the connection active.\n\n\n\n\n\n\nReturns\n\n\nbyte : the number of bytes returned from the slave device\n\n\nbeginTransmission()\n\n\nDescription\n\n\nBegin a transmission to the I2C slave device with the given address. Subsequently, queue bytes for transmission with the write() function and transmit them by calling endTransmission().\n\n\nSyntax\n\n\nWire.beginTransmission(address)\n\n\nParameters\n\n\naddress: the 7-bit address of the device to transmit to\n\n\nReturns\n\n\nNone\n\n\nendTransmission()\n\n\nDescription\n\n\nEnds a transmission to a slave device that was begun by beginTransmission() and transmits the bytes that were queued by write().\n\n\nAs of Arduino 1.0.1, endTransmission() accepts a boolean argument changing its behavior for compatibility with certain I2C devices.\n\n\nIf true, endTransmission() sends a stop message after transmission, releasing the I2C bus.\n\n\nIf false, endTransmission() sends a restart message after transmission. The bus will not be released, which prevents another master device from transmitting between messages. This allows one master device to send multiple transmissions while in control.\n\n\nThe default value is true.\n\n\nSyntax\n\n\nWire.endTransmission()\n\n\nWire.endTransmission(stop)\n\n\nParameters\n\n\n\n\nstop : boolean. true will send a stop message, releasing the bus after transmission. false will send a restart, keeping the connection active.\n\n\n\n\nReturns\n\n\nNone\n\n\nwrite()\n\n\nDescription\n\n\nWrites data from a slave device in response to a request from a master, or queues bytes for transmission from a master to slave device (in-between calls to beginTransmission() and endTransmission()).\n\n\nSyntax\n\n\nWire.write(value)\n \n\n\nWire.write(string)\n \n\n\nWire.write(data, length)\n\n\nParameters\n\n\n\n\n\n\nvalue: a value to send as a single byte\n\n\n\n\n\n\nstring: a string to send as a series of bytes\n\n\n\n\n\n\ndata: an array of data to send as bytes\n\n\n\n\n\n\nlength: the number of bytes to transmit\n\n\n\n\n\n\nReturns\n\n\nbyte: write() will return the number of bytes written, though reading that number is optional\n\n\nExample\n\n\n#include\n \nWire.h\n\n\n\nbyte\n \nval\n \n=\n \n0\n;\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nWire\n.\nbegin\n();\n \n// join i2c bus\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nWire\n.\nbeginTransmission\n(\n44\n);\n \n// transmit to device #44 (0x2c)\n\n                              \n// device address is specified in datasheet\n\n  \nWire\n.\nwrite\n(\nval\n);\n             \n// sends value byte  \n\n  \nWire\n.\nendTransmission\n();\n     \n// stop transmitting\n\n\n  \nval\n++\n;\n        \n// increment value\n\n  \nif\n(\nval\n \n==\n \n64\n)\n \n// if reached 64th position (max)\n\n  \n{\n\n    \nval\n \n=\n \n0\n;\n    \n// start over from lowest value\n\n  \n}\n\n  \ndelay\n(\n500\n);\n\n\n}\n\n\n\n\n\n\navailable()\n\n\nDescription\n\n\nReturns the number of bytes available for retrieval with read(). This should be called on a master device after a call to requestFrom() or on a slave inside the onReceive() handler.\n\n\navailable() inherits from the Stream utility class.\n\n\nParameters\n\n\nNone\n\n\nReturns\n\n\nThe number of bytes available for reading.\n\n\nExample\n\n\n\n\nRefer to example from \nread()\n\n\n\n\nread()\n\n\nDescription\n\n\nReads a byte that was transmitted from a slave device to a master after a call to requestFrom() or was transmitted from a master to a slave. read() inherits from the Stream utility class.\n\n\nSyntax\n\n\nWire.read()\n\n\nParameters\n\n\nNone\n\n\nReturns\n\n\nThe next byte received\n\n\nExample\n\n\n#include\n \nWire.h\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nWire\n.\nbegin\n();\n        \n// join i2c bus (address optional for master)\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n  \n// start serial for output\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nWire\n.\nrequestFrom\n(\n2\n,\n \n6\n);\n    \n// request 6 bytes from slave device #2\n\n\n  \nwhile\n(\nWire\n.\navailable\n())\n    \n// slave may send less than requested\n\n  \n{\n \n    \nchar\n \nc\n \n=\n \nWire\n.\nread\n();\n    \n// receive a byte as character\n\n    \nSerial\n.\nprint\n(\nc\n);\n         \n// print the character\n\n  \n}\n\n\n  \ndelay\n(\n500\n);\n\n\n}\n\n\n\n\n\n\nonReceive()\n\n\nDescription\n\n\nRegisters a function to be called when a slave device receives a transmission from a master.\n\n\nSyntax\n\n\nWire.onReceive(handler)\n\n\nParameters\n\n\n\n\nhandler: the function to be called when the slave receives data; this should take a single int parameter (the number of bytes read from the master) and return nothing, e.g.: void myHandler(int numBytes)\n\n\n\n\nReturns\n\n\nNone\n\n\nonRequest()\n\n\nDescription\n\n\nRegister a function to be called when a master requests data from this slave device.\n\n\nSyntax\n\n\nWire.onRequest(handler)\n\n\nParameters\n\n\n\n\nhandler: the function to be called, takes no parameters and returns nothing, e.g.: void myHandler()\n\n\n\n\nReturns\n\n\nNone", 
            "title": "Wire"
        }, 
        {
            "location": "/libraries/Wire/#wire-i2c", 
            "text": "This library allows you to communicate with I2C / TWI devices. On CT-ARM board, the SDA (data line) and SCL (clock line) are on the pin headers close to the AREF pin.    Note   There are both 7- and 8-bit versions of I2C addresses. 7 bits identify the device, and the eighth bit determines if it's being written to or read from. The Wire library uses 7 bit addresses throughout. If you have a datasheet or sample code that uses 8 bit address, you'll want to drop the low bit (i.e. shift the value one bit to the right), yielding an address between 0 and 127. However the addresses from 0 to 7 are not used because are reserved so the first address that can be used is 8.   Pull-up resistors  are needed when connecting SDA/SCL pins.", 
            "title": "Wire (I2C)"
        }, 
        {
            "location": "/libraries/Wire/#begin", 
            "text": "Description  Initiate the Wire library and join the I2C bus as a master or slave. This should normally be called only once.  Syntax  Wire.begin()  Wire.begin(address)  Parameters   address: the 7-bit slave address (optional); if not specified, join the bus as a master.   Returns  None  Example  #include   Wire.h  void   setup ()  { \n   Wire . begin ();  }  void   loop (){   /* Empty loop */   }", 
            "title": "begin()"
        }, 
        {
            "location": "/libraries/Wire/#requestfrom", 
            "text": "Description  Used by the master to request bytes from a slave device. The bytes may then be retrieved with the available() and read() functions.  As of Arduino 1.0.1, requestFrom() accepts a boolean argument changing its behavior for compatibility with certain I2C devices.  If true, requestFrom() sends a stop message after the request, releasing the I2C bus.  If false, requestFrom() sends a restart message after the request. The bus will not be released, which prevents another master device from requesting between messages. This allows one master device to send multiple requests while in control.  The default value is true.  Syntax  Wire.requestFrom(address, quantity)  Wire.requestFrom(address, quantity, stop)  Parameters    address: the 7-bit address of the device to request bytes from    quantity: the number of bytes to request    stop : boolean. true will send a stop message after the request, releasing the bus. false will continually send a restart after the request, keeping the connection active.    Returns  byte : the number of bytes returned from the slave device", 
            "title": "requestFrom()"
        }, 
        {
            "location": "/libraries/Wire/#begintransmission", 
            "text": "Description  Begin a transmission to the I2C slave device with the given address. Subsequently, queue bytes for transmission with the write() function and transmit them by calling endTransmission().  Syntax  Wire.beginTransmission(address)  Parameters  address: the 7-bit address of the device to transmit to  Returns  None", 
            "title": "beginTransmission()"
        }, 
        {
            "location": "/libraries/Wire/#endtransmission", 
            "text": "Description  Ends a transmission to a slave device that was begun by beginTransmission() and transmits the bytes that were queued by write().  As of Arduino 1.0.1, endTransmission() accepts a boolean argument changing its behavior for compatibility with certain I2C devices.  If true, endTransmission() sends a stop message after transmission, releasing the I2C bus.  If false, endTransmission() sends a restart message after transmission. The bus will not be released, which prevents another master device from transmitting between messages. This allows one master device to send multiple transmissions while in control.  The default value is true.  Syntax  Wire.endTransmission()  Wire.endTransmission(stop)  Parameters   stop : boolean. true will send a stop message, releasing the bus after transmission. false will send a restart, keeping the connection active.   Returns  None", 
            "title": "endTransmission()"
        }, 
        {
            "location": "/libraries/Wire/#write", 
            "text": "Description  Writes data from a slave device in response to a request from a master, or queues bytes for transmission from a master to slave device (in-between calls to beginTransmission() and endTransmission()).  Syntax  Wire.write(value)    Wire.write(string)    Wire.write(data, length)  Parameters    value: a value to send as a single byte    string: a string to send as a series of bytes    data: an array of data to send as bytes    length: the number of bytes to transmit    Returns  byte: write() will return the number of bytes written, though reading that number is optional  Example  #include   Wire.h  byte   val   =   0 ;  void   setup ()  { \n   Wire . begin ();   // join i2c bus  }  void   loop ()  { \n   Wire . beginTransmission ( 44 );   // transmit to device #44 (0x2c) \n                               // device address is specified in datasheet \n   Wire . write ( val );               // sends value byte   \n   Wire . endTransmission ();       // stop transmitting \n\n   val ++ ;          // increment value \n   if ( val   ==   64 )   // if reached 64th position (max) \n   { \n     val   =   0 ;      // start over from lowest value \n   } \n   delay ( 500 );  }", 
            "title": "write()"
        }, 
        {
            "location": "/libraries/Wire/#available", 
            "text": "Description  Returns the number of bytes available for retrieval with read(). This should be called on a master device after a call to requestFrom() or on a slave inside the onReceive() handler.  available() inherits from the Stream utility class.  Parameters  None  Returns  The number of bytes available for reading.  Example   Refer to example from  read()", 
            "title": "available()"
        }, 
        {
            "location": "/libraries/Wire/#read", 
            "text": "Description  Reads a byte that was transmitted from a slave device to a master after a call to requestFrom() or was transmitted from a master to a slave. read() inherits from the Stream utility class.  Syntax  Wire.read()  Parameters  None  Returns  The next byte received  Example  #include   Wire.h  void   setup ()  { \n   Wire . begin ();          // join i2c bus (address optional for master) \n   Serial . begin ( 9600 );    // start serial for output  }  void   loop ()  { \n   Wire . requestFrom ( 2 ,   6 );      // request 6 bytes from slave device #2 \n\n   while ( Wire . available ())      // slave may send less than requested \n   {  \n     char   c   =   Wire . read ();      // receive a byte as character \n     Serial . print ( c );           // print the character \n   } \n\n   delay ( 500 );  }", 
            "title": "read()"
        }, 
        {
            "location": "/libraries/Wire/#onreceive", 
            "text": "Description  Registers a function to be called when a slave device receives a transmission from a master.  Syntax  Wire.onReceive(handler)  Parameters   handler: the function to be called when the slave receives data; this should take a single int parameter (the number of bytes read from the master) and return nothing, e.g.: void myHandler(int numBytes)   Returns  None", 
            "title": "onReceive()"
        }, 
        {
            "location": "/libraries/Wire/#onrequest", 
            "text": "Description  Register a function to be called when a master requests data from this slave device.  Syntax  Wire.onRequest(handler)  Parameters   handler: the function to be called, takes no parameters and returns nothing, e.g.: void myHandler()   Returns  None", 
            "title": "onRequest()"
        }, 
        {
            "location": "/libraries/Serial/", 
            "text": "Serial is used for communication between the board and a computer or other devices. CT-ARM has one main serial port (also known as a UART or USART): \nSerial\n. It communicates on digital pins 0 (RX) and 1 (TX) as well as with the computer via USB. Thus, if you use these functions, you cannot also use pins 0 and 1 for digital input or output.\n\n\nYou can use the Arduino environment's built-in serial monitor to communicate with an Arduino board. Click the serial monitor button in the toolbar and select the same baud rate used in the call to begin().\n\n\nCT-ARM has 4 additional serial ports: \nSerial2\n on pins 8 (RX) and 9 (TX), \nSerial3\n on pins A4 (RX) and A5 (TX), \nSerial4\n on pins SCL (RX) and SDA (TX) , and \nSerial5\n on pins 10 (RX) and 11 (TX). To use these pins to communicate with your personal computer, you will need an additional USB-to-serial adaptor, as they are not connected to the CT-ARM's USB-to-serial adaptor. To use them to communicate with an external TTL serial device, connect the TX pin to your device's RX pin, the RX to your device's TX pin, and the ground of your CT-ARM to your device's ground.\n\n\nCT-ARM also has 1 special port: \nSerial1\n, which shares same RX and TX pins as Serial. To use Serial1, just simply cut the track between pad UART0 and center pad at the back of CT-ARM board, then solder pad UART1 and center pad together. The advantage is that pin 0 and 1 are no longer interferring with Serial debugging, and the users can use these 2 pins for another extra TTL serial device.\n\n\nThe UART pinouts are listed as below:\n\n\n\n\n\n\n\n\nUART\n\n\nRX\n\n\nTX\n\n\n\n\n\n\n\n\n\n\nSerial\n\n\n0 (default)\n\n\n1 (default)\n\n\n\n\n\n\nSerial1\n\n\n0\n\n\n1\n\n\n\n\n\n\nSerial2\n\n\n8\n\n\n9\n\n\n\n\n\n\nSerial3\n\n\nA4\n\n\nA5\n\n\n\n\n\n\nSerial4\n\n\nSCL\n\n\nSDA\n\n\n\n\n\n\nSerial5\n\n\n10\n\n\n11\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nSerial communication on pins TX/RX on CT-ARM uses TTL logic levels 5V. Don't connect these pins directly to an RS232 serial port; they operate at \n 12V and can damage your CT-ARM board. \n\n\n\n\nIf (Serial)\n\n\nDescription\n\n\nIndicates if the specified Serial port is ready.\n\n\nSyntax\n\n\nIf(Serial)\n\n\nIf(Serial1)\n\n\nIf(Serial2)\n\n\nIf(Serial3)\n\n\nIf(Serial4)\n\n\nIf(Serial5)\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nboolean : returns true if the specified serial port is available.\n\n\nExample\n\n\nvoid\n \nsetup\n()\n \n{\n \n \n//Initialize serial and wait for port to open:\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n \n  \nwhile\n \n(\n!\nSerial\n)\n \n{\n\n    \n;\n \n// wait for serial port to connect. Needed for native USB\n\n  \n}\n\n\n}\n \n\n\nvoid\n \nloop\n()\n \n{\n \n \n//proceed normally\n\n\n}\n \n\n\n\n\n\navailable()\n\n\nDescription\n\n\nGet the number of bytes (characters) available for reading from the serial port. This is data that's already arrived and stored in the serial receive buffer (which holds 64 bytes). available() inherits from the Stream utility class.\n\n\nSyntax\n\n\nSerial.available()\n\n\nSerial1.available()\n\n\nSerial2.available()\n\n\nSerial3.available()\n\n\nSerial4.available()\n\n\nSerial5.available()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nthe number of bytes available to read\n\n\nExample\n\n\nSerial Example:\n\n\nint\n \nincomingByte\n \n=\n \n0\n;\n   \n// for incoming serial data\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \n// opens serial port, sets data rate to 9600 bps\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n\n  \n// send data only when you receive data:\n\n  \nif\n \n(\nSerial\n.\navailable\n()\n \n \n0\n)\n \n{\n\n     \n// read the incoming byte:\n\n     \nincomingByte\n \n=\n \nSerial\n.\nread\n();\n\n\n     \n// say what you got:\n\n     \nSerial\n.\nprint\n(\nI received: \n);\n\n     \nSerial\n.\nprintln\n(\nincomingByte\n,\n \nDEC\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSerial2 Example:\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \n// opens port 0 and port 2, both sets data rate to 9600 bps\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n  \nSerial2\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \n// read from port 0, send to port 2:\n\n  \nif\n \n(\nSerial\n.\navailable\n())\n \n{\n\n    \nint\n \ninByte\n \n=\n \nSerial\n.\nread\n();\n\n    \nSerial2\n.\nprint\n(\ninByte\n,\n \nBYTE\n);\n \n\n  \n}\n\n  \n// read from port 2, send to port 0:\n\n  \nif\n \n(\nSerial2\n.\navailable\n())\n \n{\n\n    \nint\n \ninByte\n \n=\n \nSerial2\n.\nread\n();\n\n    \nSerial\n.\nprint\n(\ninByte\n,\n \nBYTE\n);\n \n  \n}\n\n\n}\n\n\n\n\n\n\nbegin()\n\n\nDescription\n\n\nSets the data rate in bits per second (baud) for serial data transmission. For communicating with the computer, use one of these rates: 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, or 115200. You can, however, specify other rates - for example, to communicate over pins 0 and 1 with a component that requires a particular baud rate.\n\n\nSyntax\n\n\nSerial.begin()\n\n\nSerial1.begin()\n\n\nSerial2.begin()\n\n\nSerial3.begin()\n\n\nSerial4.begin()\n\n\nSerial5.begin()\n\n\nParameters\n\n\n\n\nspeed: in bits per second (baud) - long\n\n\n\n\nReturn\n\n\nNone\n\n\nExample\n\n\nvoid\n \nsetup\n()\n \n{\n\n    \nSerial\n.\nbegin\n(\n9600\n);\n \n// opens serial port, sets data rate to 9600 bps\n\n    \nSerial2\n.\nbegin\n(\n19200\n);\n \n// opens serial port 2 , sets data rate to 19200 bps\n\n    \nSerial5\n.\nbegin\n(\n4800\n);\n \n// opens serial port 5, sets data rate to 4800 bps\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{}\n\n\n\n\n\n\nend()\n\n\nDescription\n\n\nDisables serial communication, allowing the RX and TX pins to be used for general input and output. To re-enable serial communication, call Serial.begin().\n\n\nSyntax\n\n\nSerial.end\n\n\nSerial1.end\n\n\nSerial2.end\n\n\nSerial3.end\n\n\nSerial4.end\n\n\nSerial5.end\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nNone\n\n\nfind()\n\n\nDescription\n\n\nSerial.find() reads data from the serial buffer until the target string of given length is found. The function returns true if target string is found, false if it times out.\n\n\nSerial.find() inherits from the Stream utility class.\n\n\nSyntax\n\n\nSerial.find(target)\n\n\nParameters\n\n\n\n\ntarget : the string to search for (char)\n\n\n\n\nReturn\n\n\nboolean\n\n\nfindUntil()\n\n\nDescription\n\n\nSerial.findUntil() reads data from the serial buffer until a target string of given length or terminator string is found.\n\n\nThe function returns true if the target string is found, false if it times out.\n\n\nSerial.findUntil() inherits from the Stream utility class.\n\n\nSyntax\n\n\nSerial.findUntil(target, terminal)\n\n\nParameters\n\n\n\n\ntarget : the string to search for (char)\n\n\nterminal : the terminal string in the search (char)\n\n\n\n\nReturn\n\n\nboolean\n\n\nflush()\n\n\nDescription\n\n\nWaits for the transmission of outgoing serial data to complete. (Prior to Arduino 1.0, this instead removed any buffered incoming serial data.)\n\n\nflush() inherits from the Stream utility class.\n\n\nSyntax\n\n\nSerial.flush()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nNone\n\n\npeek()\n\n\nDescription\n\n\nReturns the next byte (character) of incoming serial data without removing it from the internal serial buffer. That is, successive calls to peek() will return the same character, as will the next call to read(). peek() inherits from the Stream utility class.\n\n\nSyntax\n\n\nSerial.peek()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nthe first byte of incoming serial data available (or -1 if no data is available) - int\n\n\nprint()\n\n\nDescription\n\n\nPrints data to the serial port as human-readable ASCII text. This command can take many forms. Numbers are printed using an ASCII character for each digit. Floats are similarly printed as ASCII digits, defaulting to two decimal places. Bytes are sent as a single character. Characters and strings are sent as is. For example:\n\n\n\n\nSerial.print(78) gives \"78\"\n\n\nSerial.print(1.23456) gives \"1.23\"\n\n\nSerial.print('N') gives \"N\"\n\n\nSerial.print(\"Hello world.\") gives \"Hello world.\"\n\n\n\n\nAn optional second parameter specifies the base (format) to use; permitted values are BIN (binary, or base 2), OCT (octal, or base 8), DEC (decimal, or base 10), HEX (hexadecimal, or base 16). For floating point numbers, this parameter specifies the number of decimal places to use. For example:\n\n\n\n\nSerial.print(78, BIN) gives \"1001110\"\n\n\nSerial.print(78, OCT) gives \"116\"\n\n\nSerial.print(78, DEC) gives \"78\"\n\n\nSerial.print(78, HEX) gives \"4E\"\n\n\nSerial.println(1.23456, 0) gives \"1\"\n\n\nSerial.println(1.23456, 2) gives \"1.23\"\n\n\nSerial.println(1.23456, 4) gives \"1.2346\"\n\n\n\n\nYou can pass flash-memory based strings to Serial.print() by wrapping them with F(). For example :\n\n\n\n\nSerial.print(F(\u201cHello World\u201d))\n\n\n\n\nTo send a single byte, use \nSerial.write()\n.\n\n\nSyntax\n\n\nSerial.print(val)\n\n\nSerial.print(val, format)\n\n\nParameters\n\n\n\n\n\n\nval: the value to print - any data type\n\n\n\n\n\n\nformat: specifies the number base (for integral data types) or number of decimal places (for floating point types)\n\n\n\n\n\n\nReturn\n\n\nsize_t (long): print() returns the number of bytes written, though reading that number is optional\n\n\nExample\n\n\n/*\n\n\nUses a FOR loop for data and prints a number in various formats.\n\n\n*/\n\n\nint\n \nx\n \n=\n \n0\n;\n    \n// variable\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n      \n// open the serial port at 9600 bps:    \n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n  \n  \n// print labels \n\n  \nSerial\n.\nprint\n(\nNO FORMAT\n);\n       \n// prints a label\n\n  \nSerial\n.\nprint\n(\n\\t\n);\n              \n// prints a tab\n\n\n  \nSerial\n.\nprint\n(\nDEC\n);\n  \n  \nSerial\n.\nprint\n(\n\\t\n);\n      \n\n  \nSerial\n.\nprint\n(\nHEX\n);\n \n  \nSerial\n.\nprint\n(\n\\t\n);\n   \n\n  \nSerial\n.\nprint\n(\nOCT\n);\n\n  \nSerial\n.\nprint\n(\n\\t\n);\n\n\n  \nSerial\n.\nprint\n(\nBIN\n);\n\n  \nSerial\n.\nprint\n(\n\\t\n);\n \n\n  \nfor\n(\nx\n=\n0\n;\n \nx\n \n64\n;\n \nx\n++\n){\n    \n// only part of the ASCII chart, change to suit\n\n\n    \n// print it out in many formats:\n\n    \nSerial\n.\nprint\n(\nx\n);\n       \n// print as an ASCII-encoded decimal - same as \nDEC\n\n    \nSerial\n.\nprint\n(\n\\t\n);\n    \n// prints a tab\n\n\n    \nSerial\n.\nprint\n(\nx\n,\n \nDEC\n);\n  \n// print as an ASCII-encoded decimal\n\n    \nSerial\n.\nprint\n(\n\\t\n);\n    \n// prints a tab\n\n\n    \nSerial\n.\nprint\n(\nx\n,\n \nHEX\n);\n  \n// print as an ASCII-encoded hexadecimal\n\n    \nSerial\n.\nprint\n(\n\\t\n);\n    \n// prints a tab\n\n\n    \nSerial\n.\nprint\n(\nx\n,\n \nOCT\n);\n  \n// print as an ASCII-encoded octal\n\n    \nSerial\n.\nprint\n(\n\\t\n);\n    \n// prints a tab\n\n\n    \nSerial\n.\nprintln\n(\nx\n,\n \nBIN\n);\n  \n// print as an ASCII-encoded binary\n\n    \n//                             then adds the carriage return with \nprintln\n\n    \ndelay\n(\n200\n);\n            \n// delay 200 milliseconds\n\n  \n}\n\n  \nSerial\n.\nprintln\n(\n);\n      \n// prints another carriage return\n\n\n}\n\n\n\n\n\n\nprintln()\n\n\nDescription\n\n\nPrints data to the serial port as human-readable ASCII text followed by a carriage return character (ASCII 13, or '\\r') and a newline character (ASCII 10, or '\\n'). This command takes the same forms as \nSerial.print()\n.\n\n\nSyntax\n\n\nSerial.println(val)\n\n\nSerial.println(val, format)\n\n\nParameters\n\n\n\n\n\n\nval: the value to print - any data type\n\n\n\n\n\n\nformat: specifies the number base (for integral data types) or number of decimal places (for floating point types)\n\n\n\n\n\n\nReturn\n\n\nsize_t (long): println() returns the number of bytes written, though reading that number is optional\n\n\nExample\n\n\n/*\n\n\n  Analog input\n\n\n\n reads an analog input on analog in 0, prints the value out.\n\n\n\n created 24 March 2006\n\n\n by Tom Igoe\n\n\n */\n\n\n\nint\n \nanalogValue\n \n=\n \n0\n;\n    \n// variable to hold the analog value\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \n// open the serial port at 9600 bps:\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \n// read the analog input on pin 0:\n\n  \nanalogValue\n \n=\n \nanalogRead\n(\n0\n);\n\n\n  \n// print it out in many formats:\n\n  \nSerial\n.\nprintln\n(\nanalogValue\n);\n       \n// print as an ASCII-encoded decimal\n\n  \nSerial\n.\nprintln\n(\nanalogValue\n,\n \nDEC\n);\n  \n// print as an ASCII-encoded decimal\n\n  \nSerial\n.\nprintln\n(\nanalogValue\n,\n \nHEX\n);\n  \n// print as an ASCII-encoded hexadecimal\n\n  \nSerial\n.\nprintln\n(\nanalogValue\n,\n \nOCT\n);\n  \n// print as an ASCII-encoded octal\n\n  \nSerial\n.\nprintln\n(\nanalogValue\n,\n \nBIN\n);\n  \n// print as an ASCII-encoded binary\n\n\n  \n// delay 10 milliseconds before the next reading:\n\n  \ndelay\n(\n10\n);\n\n\n}\n\n\n\n\n\n\nread()\n\n\nDescription\n\n\nReads incoming serial data. \nread()\n inherits from the Stream utility class.\n\n\nSyntax\n\n\nSerial.read()\n\n\nSerial1.read()\n\n\nSerial2.read()\n\n\nSerial3.read()\n\n\nSerial4.read()\n\n\nSerial5.read()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nthe first byte of incoming serial data available (or -1 if no data is available) - int\n\n\nExample\n\n\nint\n \nincomingByte\n \n=\n \n0\n;\n   \n// for incoming serial data\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n     \n// opens serial port, sets data rate to 9600 bps\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \n// send data only when you receive data:\n\n  \nif\n \n(\nSerial\n.\navailable\n()\n \n \n0\n)\n \n{\n\n    \n// read the incoming byte:\n\n    \nincomingByte\n \n=\n \nSerial\n.\nread\n();\n\n\n    \n// say what you got:\n\n    \nSerial\n.\nprint\n(\nI received: \n);\n\n    \nSerial\n.\nprintln\n(\nincomingByte\n,\n \nDEC\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nreadBytes()\n\n\nDescription\n\n\nSerial.readBytes() reads characters from the serial port into a buffer. The function terminates if the determined length has been read, or it times out (see \nSerial.setTimeout()\n).\n\n\nSerial.readBytes() returns the number of characters placed in the buffer. A 0 means no valid data was found.\n\n\nSerial.readBytes() inherits from the Stream utility class.\n\n\nSyntax\n\n\nSerial.readBytes(buffer, length)\n\n\nParameters\n\n\n\n\nbuffer: the buffer to store the bytes in (char[] or byte[])\n\n\nlength : the number of bytes to read (int)\n\n\n\n\nReturn\n\n\nbyte\n\n\nreadBytesUntil()\n\n\nDescription\n\n\nSerial.readBytesUntil() reads characters from the serial buffer into an array. The function terminates if the terminator character is detected, the determined length has been read, or it times out (see \nSerial.setTimeout()\n).\n\n\nSerial.readBytesUntil() returns the number of characters read into the buffer. A 0 means no valid data was found.\n\n\nSerial.readBytesUntil() inherits from the Stream utility class.\n\n\nSyntax\n\n\nSerial.readBytesUntil(character, buffer, length)\n\n\nParameters\n\n\n\n\ncharacter : the character to search for (char)\n\n\nbuffer: the buffer to store the bytes in (char[] or byte[])\n\n\nlength : the number of bytes to read (int)\n\n\n\n\nReturn\n\n\nbyte\n\n\nreadString()\n\n\nDescription\n\n\nReads characters from the serial buffer into a string. The function terminates if it times out (see \nsetTimeout()\n).\n\n\nSyntax\n\n\nSerial.readString()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nA string read from the serial buffer\n\n\nreadStringUntil()\n\n\nDescription\n\n\nReads characters from the serial buffer into a string. The function terminates if the terminator character is detected or it times out (see \nsetTimeout()\n).\n\n\nSyntax\n\n\nSerial.readStringUntil(terminator)\n\n\nParameters\n\n\n\n\nterminator : the character to search for (char)\n\n\n\n\nReturn\n\n\nThe entire string read from the serial buffer, until the terminator character is detected\n\n\nsetTimeout()\n\n\nDescription\n\n\nSets the maximum milliseconds to wait for serial data when using \nSerial.readBytesUntil()\n and  \nSerial.readBytes()\n. It defaults to 1000 milliseconds.\n\n\nSyntax\n\n\nSerial.setTimeout(time)\n\n\nParameters\n\n\n\n\ntime : timeout duration in milliseconds (long).\n\n\n\n\nReturn\n\n\nNone\n\n\nwrite()\n\n\nDescription\n\n\nWrites binary data to the serial port. This data is sent as a byte or series of bytes; to send the characters representing the digits of a number use the \nprint()\n function instead.\n\n\nSyntax\n\n\nSerial.write(val)\n\n\nSerial.write(str)\n \n\n\nSerial.write(buf, len)\n\n\nAlso supports: \nSerial1\n, \nSerial2\n, \nSerial3\n, \nSerial4\n and \nSerial5\n (in place of Serial)\n\n\nParameters\n\n\n\n\n\n\nval: a value to send as a single byte\n\n\n\n\n\n\nstr: a string to send as a series of bytes\n\n\n\n\n\n\nbuf: an array to send as a series of bytes\n\n\n\n\n\n\nlen: the length of the buffer\n\n\n\n\n\n\nReturn\n\n\nbyte\n\n\n\n\nwrite()\n will return the number of bytes written, though reading that number is optional\n\n\n\n\nExample\n\n\nvoid\n \nsetup\n(){\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n(){\n\n  \nSerial\n.\nwrite\n(\n45\n);\n \n// send a byte with the value 45\n\n\n   \nint\n \nbytesSent\n \n=\n \nSerial\n.\nwrite\n(\n\u201c\nhello\n\u201d\n);\n \n//send the string \u201chello\u201d and return the length of the string.\n\n\n}\n\n\n\n\n\n\nserialEvent()\n\n\nDescription\n\n\nCalled when data is available. Use \nSerial.read()\n to capture this data.\n\n\nSyntax\n\n\nvoid\n \nserialEvent\n(){\n\n\n//statements\n\n\n}\n\n\n\nvoid\n \nserialEvent1\n(){\n\n\n//statements\n\n\n}\n\n\n\nvoid\n \nserialEvent2\n(){\n\n\n//statements\n\n\n}\n\n\n\nvoid\n \nserialEvent3\n(){\n\n\n//statements\n\n\n}\n\n\n\nvoid\n \nserialEvent4\n(){\n\n\n//statements\n\n\n}\n\n\n\nvoid\n \nserialEvent5\n(){\n\n\n//statements\n\n\n}\n\n\n\n\n\n\nParameters\n\n\nstatements: any valid statements", 
            "title": "Serial"
        }, 
        {
            "location": "/libraries/Serial/#if-serial", 
            "text": "Description  Indicates if the specified Serial port is ready.  Syntax  If(Serial)  If(Serial1)  If(Serial2)  If(Serial3)  If(Serial4)  If(Serial5)  Parameters  None  Return  boolean : returns true if the specified serial port is available.  Example  void   setup ()   {  \n  //Initialize serial and wait for port to open: \n   Serial . begin ( 9600 );  \n   while   ( ! Serial )   { \n     ;   // wait for serial port to connect. Needed for native USB \n   }  }   void   loop ()   {  \n  //proceed normally  }", 
            "title": "If (Serial)"
        }, 
        {
            "location": "/libraries/Serial/#available", 
            "text": "Description  Get the number of bytes (characters) available for reading from the serial port. This is data that's already arrived and stored in the serial receive buffer (which holds 64 bytes). available() inherits from the Stream utility class.  Syntax  Serial.available()  Serial1.available()  Serial2.available()  Serial3.available()  Serial4.available()  Serial5.available()  Parameters  None  Return  the number of bytes available to read  Example  Serial Example:  int   incomingByte   =   0 ;     // for incoming serial data  void   setup ()   { \n   // opens serial port, sets data rate to 9600 bps \n   Serial . begin ( 9600 );  }  void   loop ()   { \n\n   // send data only when you receive data: \n   if   ( Serial . available ()     0 )   { \n      // read the incoming byte: \n      incomingByte   =   Serial . read (); \n\n      // say what you got: \n      Serial . print ( I received:  ); \n      Serial . println ( incomingByte ,   DEC ); \n   }  }   Serial2 Example:  void   setup ()   { \n   // opens port 0 and port 2, both sets data rate to 9600 bps \n   Serial . begin ( 9600 ); \n   Serial2 . begin ( 9600 );  }  void   loop ()   { \n   // read from port 0, send to port 2: \n   if   ( Serial . available ())   { \n     int   inByte   =   Serial . read (); \n     Serial2 . print ( inByte ,   BYTE );  \n\n   } \n   // read from port 2, send to port 0: \n   if   ( Serial2 . available ())   { \n     int   inByte   =   Serial2 . read (); \n     Serial . print ( inByte ,   BYTE );  \n   }  }", 
            "title": "available()"
        }, 
        {
            "location": "/libraries/Serial/#begin", 
            "text": "Description  Sets the data rate in bits per second (baud) for serial data transmission. For communicating with the computer, use one of these rates: 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, or 115200. You can, however, specify other rates - for example, to communicate over pins 0 and 1 with a component that requires a particular baud rate.  Syntax  Serial.begin()  Serial1.begin()  Serial2.begin()  Serial3.begin()  Serial4.begin()  Serial5.begin()  Parameters   speed: in bits per second (baud) - long   Return  None  Example  void   setup ()   { \n     Serial . begin ( 9600 );   // opens serial port, sets data rate to 9600 bps \n     Serial2 . begin ( 19200 );   // opens serial port 2 , sets data rate to 19200 bps \n     Serial5 . begin ( 4800 );   // opens serial port 5, sets data rate to 4800 bps  }  void   loop ()   {}", 
            "title": "begin()"
        }, 
        {
            "location": "/libraries/Serial/#end", 
            "text": "Description  Disables serial communication, allowing the RX and TX pins to be used for general input and output. To re-enable serial communication, call Serial.begin().  Syntax  Serial.end  Serial1.end  Serial2.end  Serial3.end  Serial4.end  Serial5.end  Parameters  None  Return  None", 
            "title": "end()"
        }, 
        {
            "location": "/libraries/Serial/#find", 
            "text": "Description  Serial.find() reads data from the serial buffer until the target string of given length is found. The function returns true if target string is found, false if it times out.  Serial.find() inherits from the Stream utility class.  Syntax  Serial.find(target)  Parameters   target : the string to search for (char)   Return  boolean", 
            "title": "find()"
        }, 
        {
            "location": "/libraries/Serial/#finduntil", 
            "text": "Description  Serial.findUntil() reads data from the serial buffer until a target string of given length or terminator string is found.  The function returns true if the target string is found, false if it times out.  Serial.findUntil() inherits from the Stream utility class.  Syntax  Serial.findUntil(target, terminal)  Parameters   target : the string to search for (char)  terminal : the terminal string in the search (char)   Return  boolean", 
            "title": "findUntil()"
        }, 
        {
            "location": "/libraries/Serial/#flush", 
            "text": "Description  Waits for the transmission of outgoing serial data to complete. (Prior to Arduino 1.0, this instead removed any buffered incoming serial data.)  flush() inherits from the Stream utility class.  Syntax  Serial.flush()  Parameters  None  Return  None", 
            "title": "flush()"
        }, 
        {
            "location": "/libraries/Serial/#peek", 
            "text": "Description  Returns the next byte (character) of incoming serial data without removing it from the internal serial buffer. That is, successive calls to peek() will return the same character, as will the next call to read(). peek() inherits from the Stream utility class.  Syntax  Serial.peek()  Parameters  None  Return  the first byte of incoming serial data available (or -1 if no data is available) - int", 
            "title": "peek()"
        }, 
        {
            "location": "/libraries/Serial/#print", 
            "text": "Description  Prints data to the serial port as human-readable ASCII text. This command can take many forms. Numbers are printed using an ASCII character for each digit. Floats are similarly printed as ASCII digits, defaulting to two decimal places. Bytes are sent as a single character. Characters and strings are sent as is. For example:   Serial.print(78) gives \"78\"  Serial.print(1.23456) gives \"1.23\"  Serial.print('N') gives \"N\"  Serial.print(\"Hello world.\") gives \"Hello world.\"   An optional second parameter specifies the base (format) to use; permitted values are BIN (binary, or base 2), OCT (octal, or base 8), DEC (decimal, or base 10), HEX (hexadecimal, or base 16). For floating point numbers, this parameter specifies the number of decimal places to use. For example:   Serial.print(78, BIN) gives \"1001110\"  Serial.print(78, OCT) gives \"116\"  Serial.print(78, DEC) gives \"78\"  Serial.print(78, HEX) gives \"4E\"  Serial.println(1.23456, 0) gives \"1\"  Serial.println(1.23456, 2) gives \"1.23\"  Serial.println(1.23456, 4) gives \"1.2346\"   You can pass flash-memory based strings to Serial.print() by wrapping them with F(). For example :   Serial.print(F(\u201cHello World\u201d))   To send a single byte, use  Serial.write() .  Syntax  Serial.print(val)  Serial.print(val, format)  Parameters    val: the value to print - any data type    format: specifies the number base (for integral data types) or number of decimal places (for floating point types)    Return  size_t (long): print() returns the number of bytes written, though reading that number is optional  Example  /*  Uses a FOR loop for data and prints a number in various formats.  */  int   x   =   0 ;      // variable  void   setup ()   { \n   Serial . begin ( 9600 );        // open the serial port at 9600 bps:      }  void   loop ()   {   \n   // print labels  \n   Serial . print ( NO FORMAT );         // prints a label \n   Serial . print ( \\t );                // prints a tab \n\n   Serial . print ( DEC );   \n   Serial . print ( \\t );       \n\n   Serial . print ( HEX );  \n   Serial . print ( \\t );    \n\n   Serial . print ( OCT ); \n   Serial . print ( \\t ); \n\n   Serial . print ( BIN ); \n   Serial . print ( \\t );  \n\n   for ( x = 0 ;   x   64 ;   x ++ ){      // only part of the ASCII chart, change to suit \n\n     // print it out in many formats: \n     Serial . print ( x );         // print as an ASCII-encoded decimal - same as  DEC \n     Serial . print ( \\t );      // prints a tab \n\n     Serial . print ( x ,   DEC );    // print as an ASCII-encoded decimal \n     Serial . print ( \\t );      // prints a tab \n\n     Serial . print ( x ,   HEX );    // print as an ASCII-encoded hexadecimal \n     Serial . print ( \\t );      // prints a tab \n\n     Serial . print ( x ,   OCT );    // print as an ASCII-encoded octal \n     Serial . print ( \\t );      // prints a tab \n\n     Serial . println ( x ,   BIN );    // print as an ASCII-encoded binary \n     //                             then adds the carriage return with  println \n     delay ( 200 );              // delay 200 milliseconds \n   } \n   Serial . println ( );        // prints another carriage return  }", 
            "title": "print()"
        }, 
        {
            "location": "/libraries/Serial/#println", 
            "text": "Description  Prints data to the serial port as human-readable ASCII text followed by a carriage return character (ASCII 13, or '\\r') and a newline character (ASCII 10, or '\\n'). This command takes the same forms as  Serial.print() .  Syntax  Serial.println(val)  Serial.println(val, format)  Parameters    val: the value to print - any data type    format: specifies the number base (for integral data types) or number of decimal places (for floating point types)    Return  size_t (long): println() returns the number of bytes written, though reading that number is optional  Example  /*    Analog input   reads an analog input on analog in 0, prints the value out.   created 24 March 2006   by Tom Igoe   */  int   analogValue   =   0 ;      // variable to hold the analog value  void   setup ()   { \n   // open the serial port at 9600 bps: \n   Serial . begin ( 9600 );  }  void   loop ()   { \n   // read the analog input on pin 0: \n   analogValue   =   analogRead ( 0 ); \n\n   // print it out in many formats: \n   Serial . println ( analogValue );         // print as an ASCII-encoded decimal \n   Serial . println ( analogValue ,   DEC );    // print as an ASCII-encoded decimal \n   Serial . println ( analogValue ,   HEX );    // print as an ASCII-encoded hexadecimal \n   Serial . println ( analogValue ,   OCT );    // print as an ASCII-encoded octal \n   Serial . println ( analogValue ,   BIN );    // print as an ASCII-encoded binary \n\n   // delay 10 milliseconds before the next reading: \n   delay ( 10 );  }", 
            "title": "println()"
        }, 
        {
            "location": "/libraries/Serial/#read", 
            "text": "Description  Reads incoming serial data.  read()  inherits from the Stream utility class.  Syntax  Serial.read()  Serial1.read()  Serial2.read()  Serial3.read()  Serial4.read()  Serial5.read()  Parameters  None  Return  the first byte of incoming serial data available (or -1 if no data is available) - int  Example  int   incomingByte   =   0 ;     // for incoming serial data  void   setup ()   { \n   Serial . begin ( 9600 );       // opens serial port, sets data rate to 9600 bps  }  void   loop ()   { \n   // send data only when you receive data: \n   if   ( Serial . available ()     0 )   { \n     // read the incoming byte: \n     incomingByte   =   Serial . read (); \n\n     // say what you got: \n     Serial . print ( I received:  ); \n     Serial . println ( incomingByte ,   DEC ); \n   }  }", 
            "title": "read()"
        }, 
        {
            "location": "/libraries/Serial/#readbytes", 
            "text": "Description  Serial.readBytes() reads characters from the serial port into a buffer. The function terminates if the determined length has been read, or it times out (see  Serial.setTimeout() ).  Serial.readBytes() returns the number of characters placed in the buffer. A 0 means no valid data was found.  Serial.readBytes() inherits from the Stream utility class.  Syntax  Serial.readBytes(buffer, length)  Parameters   buffer: the buffer to store the bytes in (char[] or byte[])  length : the number of bytes to read (int)   Return  byte", 
            "title": "readBytes()"
        }, 
        {
            "location": "/libraries/Serial/#readbytesuntil", 
            "text": "Description  Serial.readBytesUntil() reads characters from the serial buffer into an array. The function terminates if the terminator character is detected, the determined length has been read, or it times out (see  Serial.setTimeout() ).  Serial.readBytesUntil() returns the number of characters read into the buffer. A 0 means no valid data was found.  Serial.readBytesUntil() inherits from the Stream utility class.  Syntax  Serial.readBytesUntil(character, buffer, length)  Parameters   character : the character to search for (char)  buffer: the buffer to store the bytes in (char[] or byte[])  length : the number of bytes to read (int)   Return  byte", 
            "title": "readBytesUntil()"
        }, 
        {
            "location": "/libraries/Serial/#readstring", 
            "text": "Description  Reads characters from the serial buffer into a string. The function terminates if it times out (see  setTimeout() ).  Syntax  Serial.readString()  Parameters  None  Return  A string read from the serial buffer", 
            "title": "readString()"
        }, 
        {
            "location": "/libraries/Serial/#readstringuntil", 
            "text": "Description  Reads characters from the serial buffer into a string. The function terminates if the terminator character is detected or it times out (see  setTimeout() ).  Syntax  Serial.readStringUntil(terminator)  Parameters   terminator : the character to search for (char)   Return  The entire string read from the serial buffer, until the terminator character is detected", 
            "title": "readStringUntil()"
        }, 
        {
            "location": "/libraries/Serial/#settimeout", 
            "text": "Description  Sets the maximum milliseconds to wait for serial data when using  Serial.readBytesUntil()  and   Serial.readBytes() . It defaults to 1000 milliseconds.  Syntax  Serial.setTimeout(time)  Parameters   time : timeout duration in milliseconds (long).   Return  None", 
            "title": "setTimeout()"
        }, 
        {
            "location": "/libraries/Serial/#write", 
            "text": "Description  Writes binary data to the serial port. This data is sent as a byte or series of bytes; to send the characters representing the digits of a number use the  print()  function instead.  Syntax  Serial.write(val)  Serial.write(str)    Serial.write(buf, len)  Also supports:  Serial1 ,  Serial2 ,  Serial3 ,  Serial4  and  Serial5  (in place of Serial)  Parameters    val: a value to send as a single byte    str: a string to send as a series of bytes    buf: an array to send as a series of bytes    len: the length of the buffer    Return  byte   write()  will return the number of bytes written, though reading that number is optional   Example  void   setup (){ \n   Serial . begin ( 9600 );  }  void   loop (){ \n   Serial . write ( 45 );   // send a byte with the value 45 \n\n    int   bytesSent   =   Serial . write ( \u201c hello \u201d );   //send the string \u201chello\u201d and return the length of the string.  }", 
            "title": "write()"
        }, 
        {
            "location": "/libraries/Serial/#serialevent", 
            "text": "Description  Called when data is available. Use  Serial.read()  to capture this data.  Syntax  void   serialEvent (){  //statements  }  void   serialEvent1 (){  //statements  }  void   serialEvent2 (){  //statements  }  void   serialEvent3 (){  //statements  }  void   serialEvent4 (){  //statements  }  void   serialEvent5 (){  //statements  }   Parameters  statements: any valid statements", 
            "title": "serialEvent()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/", 
            "text": "The SoftwareSerial library has been developed to allow serial communication on other digital pins of CT-ARM, using software to replicate the functionality of native hardware Serial (hence the name \"SoftwareSerial\"). In CT-ARM, all I/O pins can be used for SoftwareSerial.\n\n\nHowever, there is a few limitations:\n\n\n\n\nIf using multiple software serial ports, only one can receive data at a time.\n\n\nHigher the baud rate, the less stable the data reception on RX pins. 9600 baud or below is the most stable baud rate tested for data transmission. For higher baud rate needed in applications, \nSerial\n would be recommended.\n\n\n\n\nSoftwareSerial()\n\n\nDescription\n\n\nSoftwareSerial is used to create an instance of a SoftwareSerial object, whose name you need to provide as in the example below. The inverse_logic argument is optional and defaults to false. See below for more details about what it does. Multiple SoftwareSerial objects may be created, however only one can be active at a given moment.\n\n\nYou need to call \nbegin()\n to enable communication.\n\n\nSyntax\n\n\nSoftwareSerial mySerial(rxPin, txPin)\n\n\nParameters\n\n\n\n\n\n\nrxPin: the pin on which to receive serial data\n\n\n\n\n\n\ntxPin: the pin on which to transmit serial data\n\n\n\n\n\n\ninverse_logic: is used to invert the sense of incoming bits (the default is normal logic). If set, SoftwareSerial treats a LOW (0 volts on the pin, normally) on the Rx pin as a 1-bit (the idle state) and a HIGH (5 volts on the pin, normally) as a 0-bit. It also affects the way that it writes to the Tx pin. Default value is false.\n\n\n\n\n\n\nExample\n\n\n#include\n \nSoftwareSerial.h\n\n\n\nconst\n \nbyte\n \nrxPin\n \n=\n \n2\n;\n\n\nconst\n \nbyte\n \ntxPin\n \n=\n \n3\n;\n\n\n\n// set up a new serial object\n\n\nSoftwareSerial\n \nmySerial\n \n(\nrxPin\n,\n \ntxPin\n);\n\n\n\n\n\n\navailable()\n\n\nDescription\n\n\nGet the number of bytes (characters) available for reading from a software serial port. This is data that's already arrived and stored in the serial receive buffer.\n\n\nSyntax\n\n\nmySerial.available()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nthe number of bytes available to read\n\n\nExample\n\n\n// include the SoftwareSerial library so you can use its functions:\n\n\n#include\n \nSoftwareSerial.h\n\n\n\n#define rxPin 10\n\n\n#define txPin 11\n\n\n\n// set up a new serial port\n\n\nSoftwareSerial\n \nmySerial\n \n=\n  \nSoftwareSerial\n(\nrxPin\n,\n \ntxPin\n);\n\n\n\nvoid\n \nsetup\n()\n  \n{\n\n  \n// define pin modes for tx, rx:\n\n  \npinMode\n(\nrxPin\n,\n \nINPUT\n);\n\n  \npinMode\n(\ntxPin\n,\n \nOUTPUT\n);\n\n  \n// set the data rate for the SoftwareSerial port\n\n  \nmySerial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \nif\n \n(\nmySerial\n.\navailable\n()\n0\n){\n\n    \nmySerial\n.\nread\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\nbegin()\n\n\nDescription\n\n\nSets the speed (baud rate) for the serial communication. Supported baud rates are 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200.\n\n\nSyntax\n\n\nmySerial.begin(speed)\n\n\nParameters\n\n\n\n\nspeed: the baud rate (long)\n\n\n\n\nReturn\n\n\nNone\n\n\nExample\n\n\n// include the SoftwareSerial library so you can use its functions:\n\n\n#include\n \nSoftwareSerial.h\n\n\n\n#define rxPin 10\n\n\n#define txPin 11\n\n\n\n// set up a new serial port\n\n\nSoftwareSerial\n \nmySerial\n \n=\n  \nSoftwareSerial\n(\nrxPin\n,\n \ntxPin\n);\n\n\n\nvoid\n \nsetup\n()\n  \n{\n\n  \n// define pin modes for tx, rx:\n\n  \npinMode\n(\nrxPin\n,\n \nINPUT\n);\n\n  \npinMode\n(\ntxPin\n,\n \nOUTPUT\n);\n\n  \n// set the data rate for the SoftwareSerial port\n\n  \nmySerial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\nisListening()\n\n\nDescription\n\n\nTests to see if requested software serial port is actively listening.\n\n\nSyntax\n\n\nmySerial.isListening()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nboolean\n\n\nExample\n\n\n#include\n \nSoftwareSerial.h\n\n\n\n// software serial : TX = digital pin 10, RX = digital pin 11\n\n\nSoftwareSerial\n \nportOne\n(\n10\n,\n11\n);\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \n// Start the hardware serial port\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n\n  \n// Start software serial port\n\n  \nportOne\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nif\n \n(\nportOne\n.\nisListening\n())\n \n{\n\n   \nSerial\n.\nprintln\n(\nPort One is listening!\n);\n \n\n}\n\n\n\n\n\n\noverflow()\n\n\nDescription\n\n\nTests to see if a software serial buffer overflow has occurred. Calling this function clears the overflow flag, meaning that subsequent calls will return false unless another byte of data has been received and discarded in the meantime.\n\n\nThe software serial buffer can hold 64 bytes.\n\n\nSyntax\n\n\nmySerial.overflow()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nboolean\n\n\nExample\n\n\n#include\n \nSoftwareSerial.h\n\n\n\n// software serial : TX = digital pin 10, RX = digital pin 11\n\n\nSoftwareSerial\n \nportOne\n(\n10\n,\n11\n);\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \n// Start the hardware serial port\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n\n  \n// Start software serial port\n\n  \nportOne\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nif\n \n(\nportOne\n.\noverflow\n())\n \n{\n\n   \nSerial\n.\nprintln\n(\nSoftwareSerial overflow!\n);\n \n\n}\n\n\n\n\n\n\npeek()\n\n\nDescription\n\n\nReturn a character that was received on the RX pin of the software serial port. Unlike read(), however, subsequent calls to this function will return the same character.\n\n\nNote that only one SoftwareSerial instance can receive incoming data at a time (select which one with the \nlisten()\n function).\n\n\nSyntax\n\n\nmySerial.peek()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nthe character read, or -1 if none is available\n\n\nExample\n\n\nSoftwareSerial\n \nmySerial\n(\n10\n,\n11\n);\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nmySerial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nchar\n \nc\n \n=\n \nmySerial\n.\npeek\n();\n\n\n}\n\n\n\n\n\n\nread()\n\n\nDescription\n\n\nReturn a character that was received on the RX pin of the software serial port. Note that only one SoftwareSerial instance can receive incoming data at a time (select which one with the \nlisten()\n function).\n\n\nSyntax\n\n\nmySerial.read()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nthe character read, or -1 if none is available\n\n\nExample\n\n\nSoftwareSerial\n \nmySerial\n(\n10\n,\n11\n);\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nmySerial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nchar\n \nc\n \n=\n \nmySerial\n.\nread\n();\n\n\n}\n\n\n\n\n\n\nprint()\n\n\nDescription\n\n\nPrints data to the transmit pin of the software serial port. Works the same as the \nSerial.print()\n function.\n\n\nSyntax\n\n\nmySerial.print()\n\n\nParameters\n\n\nvary, see \nSerial.print()\n for details\n\n\nReturn\n\n\nbyte\n\n\n\n\nprint()\n will return the number of bytes written, though reading that number is optional\n\n\n\n\nExample\n\n\nSoftwareSerial\n \nserial\n(\n10\n,\n11\n);\n\n\nint\n \nanalogValue\n;\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nserial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \n// read the analog input on pin 0:\n\n  \nanalogValue\n \n=\n \nanalogRead\n(\nA0\n);\n\n\n  \n// print it out in many formats:\n\n  \nserial\n.\nprint\n(\nanalogValue\n);\n         \n// print as an ASCII-encoded decimal\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n,\n \nDEC\n);\n    \n// print as an ASCII-encoded decimal\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n,\n \nHEX\n);\n    \n// print as an ASCII-encoded hexadecimal\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n,\n \nOCT\n);\n    \n// print as an ASCII-encoded octal\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n,\n \nBIN\n);\n    \n// print as an ASCII-encoded binary\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n/\n4\n,\n \nBYTE\n);\n \n// print as a raw byte value (divide the\n\n                                     \n// value by 4 because analogRead() returns numbers\n\n                                     \n// from 0 to 1023, but a byte can only hold values\n\n                                     \n// up to 255)\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character    \n\n  \nserial\n.\nprintln\n();\n                  \n// print a linefeed character\n\n\n  \n// delay 10 milliseconds before the next reading:\n\n  \ndelay\n(\n10\n);\n\n\n}\n\n\n\n\n\n\nprintln()\n\n\nDescription\n\n\nPrints data to the transmit pin of the software serial port, followed by a carriage return and line feed. Works the same as the \nSerial.println()\n function.\n\n\nSyntax\n\n\nmySerial.println()\n\n\nParameters\n\n\nvary, see \nSerial.println()\n for details\n\n\nReturn\n\n\nbyte\n\n\n\n\nprintln()\n will return the number of bytes written, though reading that number is optional\n\n\n\n\nExample\n\n\nSoftwareSerial\n \nserial\n(\n10\n,\n11\n);\n\n\nint\n \nanalogValue\n;\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nserial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \n// read the analog input on pin 0:\n\n  \nanalogValue\n \n=\n \nanalogRead\n(\nA0\n);\n\n\n  \n// print it out in many formats:\n\n  \nserial\n.\nprint\n(\nanalogValue\n);\n         \n// print as an ASCII-encoded decimal\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n,\n \nDEC\n);\n    \n// print as an ASCII-encoded decimal\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n,\n \nHEX\n);\n    \n// print as an ASCII-encoded hexadecimal\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n,\n \nOCT\n);\n    \n// print as an ASCII-encoded octal\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n,\n \nBIN\n);\n    \n// print as an ASCII-encoded binary\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character\n\n  \nserial\n.\nprint\n(\nanalogValue\n/\n4\n,\n \nBYTE\n);\n \n// print as a raw byte value (divide the\n\n                                     \n// value by 4 because analogRead() returns numbers\n\n                                     \n// from 0 to 1023, but a byte can only hold values\n\n                                     \n// up to 255)\n\n  \nserial\n.\nprint\n(\n\\t\n);\n                \n// print a tab character    \n\n  \nserial\n.\nprintln\n();\n                  \n// print a linefeed character\n\n\n  \n// delay 10 milliseconds before the next reading:\n\n  \ndelay\n(\n10\n);\n\n\n}\n\n\n\n\n\n\nlisten()\n\n\nDescription\n\n\nEnables the selected software serial port to listen. Only one software serial port can listen at a time; data that arrives for other ports will be discarded. Any data already received is discarded during the call to listen() (unless the given instance is already listening).\n\n\nSyntax\n\n\nmySerial.listen()\n\n\nParameters\n\n\nmySerial:the name of the instance to listen\n\n\nReturn\n\n\nNone\n\n\nExample\n\n\n#include\n \nSoftwareSerial.h\n\n\n\n// software serial : TX = digital pin 10, RX = digital pin 11\n\n\nSoftwareSerial\n \nportOne\n(\n10\n,\n \n11\n);\n\n\n\n// software serial : TX = digital pin 8, RX = digital pin 9\n\n\nSoftwareSerial\n \nportTwo\n(\n8\n,\n \n9\n);\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \n// Start the hardware serial port\n\n  \nSerial\n.\nbegin\n(\n9600\n);\n\n\n  \n// Start both software serial ports\n\n  \nportOne\n.\nbegin\n(\n9600\n);\n\n  \nportTwo\n.\nbegin\n(\n9600\n);\n\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \nportOne\n.\nlisten\n();\n\n\n  \nif\n \n(\nportOne\n.\nisListening\n())\n \n{\n\n   \nSerial\n.\nprintln\n(\nPort One is listening!\n);\n \n\n}\nelse\n{\n\n   \nSerial\n.\nprintln\n(\nPort One is not listening!\n);\n \n\n}\n\n\n  \nif\n \n(\nportTwo\n.\nisListening\n())\n \n{\n\n   \nSerial\n.\nprintln\n(\nPort Two is listening!\n);\n \n\n}\nelse\n{\n\n   \nSerial\n.\nprintln\n(\nPort Two is not listening!\n);\n \n\n}\n\n\n\n}\n\n\n\n\n\n\nwrite()\n\n\nDescription\n\n\nPrints data to the transmit pin of the software serial port as raw bytes. Works the same as the \nSerial.write()\n function.\n\n\nSyntax\n\n\nmySerial.write(data)\n\n\nParameters\n\n\n\n\ndata: refer to \nSerial.write()\n for details\n\n\n\n\nReturn\n\n\nbyte\n\n\n\n\nwrite()\n will return the number of bytes written, though reading that number is optional\n\n\n\n\nExample\n\n\nSoftwareSerial\n \nmySerial\n(\n10\n,\n \n11\n);\n\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \nmySerial\n.\nbegin\n(\n9600\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \n// send a byte with the value 45\n\n  \nmySerial\n.\nwrite\n(\n45\n);\n\n\n  \n//send the string \u201chello\u201d and return the length of the string.\n\n  \nint\n \nbytesSent\n \n=\n \nmySerial\n.\nwrite\n(\n\u201c\nhello\n\u201d\n);\n\n\n}", 
            "title": "SoftwareSerial"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#softwareserial", 
            "text": "Description  SoftwareSerial is used to create an instance of a SoftwareSerial object, whose name you need to provide as in the example below. The inverse_logic argument is optional and defaults to false. See below for more details about what it does. Multiple SoftwareSerial objects may be created, however only one can be active at a given moment.  You need to call  begin()  to enable communication.  Syntax  SoftwareSerial mySerial(rxPin, txPin)  Parameters    rxPin: the pin on which to receive serial data    txPin: the pin on which to transmit serial data    inverse_logic: is used to invert the sense of incoming bits (the default is normal logic). If set, SoftwareSerial treats a LOW (0 volts on the pin, normally) on the Rx pin as a 1-bit (the idle state) and a HIGH (5 volts on the pin, normally) as a 0-bit. It also affects the way that it writes to the Tx pin. Default value is false.    Example  #include   SoftwareSerial.h  const   byte   rxPin   =   2 ;  const   byte   txPin   =   3 ;  // set up a new serial object  SoftwareSerial   mySerial   ( rxPin ,   txPin );", 
            "title": "SoftwareSerial()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#available", 
            "text": "Description  Get the number of bytes (characters) available for reading from a software serial port. This is data that's already arrived and stored in the serial receive buffer.  Syntax  mySerial.available()  Parameters  None  Return  the number of bytes available to read  Example  // include the SoftwareSerial library so you can use its functions:  #include   SoftwareSerial.h  #define rxPin 10  #define txPin 11  // set up a new serial port  SoftwareSerial   mySerial   =    SoftwareSerial ( rxPin ,   txPin );  void   setup ()    { \n   // define pin modes for tx, rx: \n   pinMode ( rxPin ,   INPUT ); \n   pinMode ( txPin ,   OUTPUT ); \n   // set the data rate for the SoftwareSerial port \n   mySerial . begin ( 9600 );  }  void   loop ()   { \n   if   ( mySerial . available () 0 ){ \n     mySerial . read (); \n   }  }", 
            "title": "available()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#begin", 
            "text": "Description  Sets the speed (baud rate) for the serial communication. Supported baud rates are 1200, 2400, 4800, 9600, 19200, 38400, 57600, and 115200.  Syntax  mySerial.begin(speed)  Parameters   speed: the baud rate (long)   Return  None  Example  // include the SoftwareSerial library so you can use its functions:  #include   SoftwareSerial.h  #define rxPin 10  #define txPin 11  // set up a new serial port  SoftwareSerial   mySerial   =    SoftwareSerial ( rxPin ,   txPin );  void   setup ()    { \n   // define pin modes for tx, rx: \n   pinMode ( rxPin ,   INPUT ); \n   pinMode ( txPin ,   OUTPUT ); \n   // set the data rate for the SoftwareSerial port \n   mySerial . begin ( 9600 );  }  void   loop ()   { \n   // ...  }", 
            "title": "begin()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#islistening", 
            "text": "Description  Tests to see if requested software serial port is actively listening.  Syntax  mySerial.isListening()  Parameters  None  Return  boolean  Example  #include   SoftwareSerial.h  // software serial : TX = digital pin 10, RX = digital pin 11  SoftwareSerial   portOne ( 10 , 11 );  void   setup ()  { \n   // Start the hardware serial port \n   Serial . begin ( 9600 ); \n\n   // Start software serial port \n   portOne . begin ( 9600 );  }  void   loop ()  { \n   if   ( portOne . isListening ())   { \n    Serial . println ( Port One is listening! );   }", 
            "title": "isListening()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#overflow", 
            "text": "Description  Tests to see if a software serial buffer overflow has occurred. Calling this function clears the overflow flag, meaning that subsequent calls will return false unless another byte of data has been received and discarded in the meantime.  The software serial buffer can hold 64 bytes.  Syntax  mySerial.overflow()  Parameters  None  Return  boolean  Example  #include   SoftwareSerial.h  // software serial : TX = digital pin 10, RX = digital pin 11  SoftwareSerial   portOne ( 10 , 11 );  void   setup ()  { \n   // Start the hardware serial port \n   Serial . begin ( 9600 ); \n\n   // Start software serial port \n   portOne . begin ( 9600 );  }  void   loop ()  { \n   if   ( portOne . overflow ())   { \n    Serial . println ( SoftwareSerial overflow! );   }", 
            "title": "overflow()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#peek", 
            "text": "Description  Return a character that was received on the RX pin of the software serial port. Unlike read(), however, subsequent calls to this function will return the same character.  Note that only one SoftwareSerial instance can receive incoming data at a time (select which one with the  listen()  function).  Syntax  mySerial.peek()  Parameters  None  Return  the character read, or -1 if none is available  Example  SoftwareSerial   mySerial ( 10 , 11 );  void   setup ()  { \n   mySerial . begin ( 9600 );  }  void   loop ()  { \n   char   c   =   mySerial . peek ();  }", 
            "title": "peek()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#read", 
            "text": "Description  Return a character that was received on the RX pin of the software serial port. Note that only one SoftwareSerial instance can receive incoming data at a time (select which one with the  listen()  function).  Syntax  mySerial.read()  Parameters  None  Return  the character read, or -1 if none is available  Example  SoftwareSerial   mySerial ( 10 , 11 );  void   setup ()  { \n   mySerial . begin ( 9600 );  }  void   loop ()  { \n   char   c   =   mySerial . read ();  }", 
            "title": "read()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#print", 
            "text": "Description  Prints data to the transmit pin of the software serial port. Works the same as the  Serial.print()  function.  Syntax  mySerial.print()  Parameters  vary, see  Serial.print()  for details  Return  byte   print()  will return the number of bytes written, though reading that number is optional   Example  SoftwareSerial   serial ( 10 , 11 );  int   analogValue ;  void   setup ()  { \n   serial . begin ( 9600 );  }  void   loop ()  { \n   // read the analog input on pin 0: \n   analogValue   =   analogRead ( A0 ); \n\n   // print it out in many formats: \n   serial . print ( analogValue );           // print as an ASCII-encoded decimal \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue ,   DEC );      // print as an ASCII-encoded decimal \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue ,   HEX );      // print as an ASCII-encoded hexadecimal \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue ,   OCT );      // print as an ASCII-encoded octal \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue ,   BIN );      // print as an ASCII-encoded binary \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue / 4 ,   BYTE );   // print as a raw byte value (divide the \n                                      // value by 4 because analogRead() returns numbers \n                                      // from 0 to 1023, but a byte can only hold values \n                                      // up to 255) \n   serial . print ( \\t );                  // print a tab character     \n   serial . println ();                    // print a linefeed character \n\n   // delay 10 milliseconds before the next reading: \n   delay ( 10 );  }", 
            "title": "print()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#println", 
            "text": "Description  Prints data to the transmit pin of the software serial port, followed by a carriage return and line feed. Works the same as the  Serial.println()  function.  Syntax  mySerial.println()  Parameters  vary, see  Serial.println()  for details  Return  byte   println()  will return the number of bytes written, though reading that number is optional   Example  SoftwareSerial   serial ( 10 , 11 );  int   analogValue ;  void   setup ()  { \n   serial . begin ( 9600 );  }  void   loop ()  { \n   // read the analog input on pin 0: \n   analogValue   =   analogRead ( A0 ); \n\n   // print it out in many formats: \n   serial . print ( analogValue );           // print as an ASCII-encoded decimal \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue ,   DEC );      // print as an ASCII-encoded decimal \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue ,   HEX );      // print as an ASCII-encoded hexadecimal \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue ,   OCT );      // print as an ASCII-encoded octal \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue ,   BIN );      // print as an ASCII-encoded binary \n   serial . print ( \\t );                  // print a tab character \n   serial . print ( analogValue / 4 ,   BYTE );   // print as a raw byte value (divide the \n                                      // value by 4 because analogRead() returns numbers \n                                      // from 0 to 1023, but a byte can only hold values \n                                      // up to 255) \n   serial . print ( \\t );                  // print a tab character     \n   serial . println ();                    // print a linefeed character \n\n   // delay 10 milliseconds before the next reading: \n   delay ( 10 );  }", 
            "title": "println()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#listen", 
            "text": "Description  Enables the selected software serial port to listen. Only one software serial port can listen at a time; data that arrives for other ports will be discarded. Any data already received is discarded during the call to listen() (unless the given instance is already listening).  Syntax  mySerial.listen()  Parameters  mySerial:the name of the instance to listen  Return  None  Example  #include   SoftwareSerial.h  // software serial : TX = digital pin 10, RX = digital pin 11  SoftwareSerial   portOne ( 10 ,   11 );  // software serial : TX = digital pin 8, RX = digital pin 9  SoftwareSerial   portTwo ( 8 ,   9 );  void   setup ()  { \n   // Start the hardware serial port \n   Serial . begin ( 9600 ); \n\n   // Start both software serial ports \n   portOne . begin ( 9600 ); \n   portTwo . begin ( 9600 );  }  void   loop ()  { \n   portOne . listen (); \n\n   if   ( portOne . isListening ())   { \n    Serial . println ( Port One is listening! );   } else { \n    Serial . println ( Port One is not listening! );   } \n\n   if   ( portTwo . isListening ())   { \n    Serial . println ( Port Two is listening! );   } else { \n    Serial . println ( Port Two is not listening! );   }  }", 
            "title": "listen()"
        }, 
        {
            "location": "/libraries/SoftwareSerial/#write", 
            "text": "Description  Prints data to the transmit pin of the software serial port as raw bytes. Works the same as the  Serial.write()  function.  Syntax  mySerial.write(data)  Parameters   data: refer to  Serial.write()  for details   Return  byte   write()  will return the number of bytes written, though reading that number is optional   Example  SoftwareSerial   mySerial ( 10 ,   11 );  void   setup ()  { \n   mySerial . begin ( 9600 );  }  void   loop ()  { \n   // send a byte with the value 45 \n   mySerial . write ( 45 ); \n\n   //send the string \u201chello\u201d and return the length of the string. \n   int   bytesSent   =   mySerial . write ( \u201c hello \u201d );  }", 
            "title": "write()"
        }, 
        {
            "location": "/libraries/SPI/", 
            "text": "SPISettings\n\n\nDescription\n\n\nThe SPISettings object is used to configure the SPI port for your SPI device. All 3 parameters are combined to a single SPISettings object, which is given to SPI.beginTransaction().\n\n\nSyntax\n\n\nSPISettings mySetting(speedMaximum, dataOrder, dataMode)\n\n\nSPI.beginTransaction(mySetting)\n\n\nParameters\n\n\n\n\n\n\nspeedMaximum: The maximum speed of communication. For a SPI chip rated up to 20 MHz, use 20000000.\n\n\n\n\n\n\ndataOrder: MSBFIRST or LSBFIRST\n\n\n\n\n\n\ndataMode : SPI_MODE0, SPI_MODE1, SPI_MODE2, or SPI_MODE3\n\n\n\n\n\n\nReturn\n\n\nNone\n\n\nbegin()\n\n\nDescription\n\n\nInitializes the SPI bus by setting SCK, MOSI, and SS to outputs, pulling SCK and MOSI low, and SS high.\n\n\nSyntax\n\n\nSPI.begin()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nNone\n\n\nExample\n\n\nend()\n\n\nDescription\n\n\nDisables the SPI bus (leaving pin modes unchanged).\n\n\nSyntax\n\n\nSPI.end()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nNone\n\n\nbeginTransaction()\n\n\nDescription\n\n\nInitializes the SPI bus using the defined \nSPISettings\n.\n\n\nSyntax\n\n\nSPI.beginTransaction(mySettings);\n\n\nParameters\n\n\n\n\nmySettings: the chosen settings according to SPISettings.\n\n\n\n\nReturn\n\n\nNone\n\n\nendTransaction()\n\n\nDescription\n\n\nStop using the SPI bus. Normally this is called after de-asserting the chip select, to allow other libraries to use the SPI bus.\n\n\nSyntax\n\n\nSPI.endTransaction()\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nNone\n\n\nsetBitOrder()\n\n\nDescription\n\n\nSets the order of the bits shifted out of and into the SPI bus, either LSBFIRST (least-significant bit first) or MSBFIRST (most-significant bit first).\n\n\nSyntax\n\n\nSPI.setBitOrder(order)\n\n\nParameters\n\n\n\n\norder: either LSBFIRST or MSBFIRST\n\n\n\n\nReturn\n\n\nNone\n\n\nsetClockDivider()\n\n\nDescription\n\n\nSets the SPI clock divider relative to the system clock. The dividers available are 2, 4, 8, 16, 32, 64 or 128. The default setting is SPI_CLOCK_DIV4, which sets the SPI clock to one-quarter the frequency of the Arduino system clock (4 Mhz for the boards at 16 MHz).\n\n\nSyntax\n\n\nSPI.setClockDivider(divider)\n\n\nParameters\n\n\n\n\ndivider:\n\n\nSPI_CLOCK_DIV2 (8MHz)\n\n\nSPI_CLOCK_DIV4 (4MHz, default)\n\n\nSPI_CLOCK_DIV8 (2MHz)\n\n\nSPI_CLOCK_DIV16 (1MHz)\n\n\nSPI_CLOCK_DIV32 (500kHz) \n\n\nSPI_CLOCK_DIV64 (250kHz)\n\n\nSPI_CLOCK_DIV128 (125kHz)\n\n\n\n\n\n\n\n\nReturn\n\n\nNone\n\n\nsetDataMode()\n\n\nDescription\n\n\nSets the SPI data mode: that is, clock polarity and phase. See the \nWikipedia article on SPI\n for details.\n\n\nSyntax\n\n\nSPI.setDataMode(mode)\n\n\nParameters\n\n\n\n\nmode:    \n\n\nSPI_MODE0\n\n\nSPI_MODE1\n\n\nSPI_MODE2\n\n\nSPI_MODE3\n\n\n\n\n\n\n\n\nReturn\n\n\nNone\n\n\ntransfer()\n\n\nDescription\n\n\nSPI transfer is based on a simultaneous send and receive: the received data is returned in receivedVal (or receivedVal16). In case of buffer transfers the received data is stored in the buffer in-place (the old data is replaced with the data received).\n\n\nSyntax\n\n\nreceivedVal = SPI.transfer(val)\n\n\nSPI.transfer(buffer, size)\n\n\nParameters\n\n\n\n\n\n\nval: the byte to send out over the bus\n\n\n\n\n\n\nbuffer: the array of data to be transferred\n\n\n\n\n\n\nReturn\n\n\nthe received data", 
            "title": "SPI"
        }, 
        {
            "location": "/libraries/SPI/#spisettings", 
            "text": "Description  The SPISettings object is used to configure the SPI port for your SPI device. All 3 parameters are combined to a single SPISettings object, which is given to SPI.beginTransaction().  Syntax  SPISettings mySetting(speedMaximum, dataOrder, dataMode)  SPI.beginTransaction(mySetting)  Parameters    speedMaximum: The maximum speed of communication. For a SPI chip rated up to 20 MHz, use 20000000.    dataOrder: MSBFIRST or LSBFIRST    dataMode : SPI_MODE0, SPI_MODE1, SPI_MODE2, or SPI_MODE3    Return  None", 
            "title": "SPISettings"
        }, 
        {
            "location": "/libraries/SPI/#begin", 
            "text": "Description  Initializes the SPI bus by setting SCK, MOSI, and SS to outputs, pulling SCK and MOSI low, and SS high.  Syntax  SPI.begin()  Parameters  None  Return  None  Example", 
            "title": "begin()"
        }, 
        {
            "location": "/libraries/SPI/#end", 
            "text": "Description  Disables the SPI bus (leaving pin modes unchanged).  Syntax  SPI.end()  Parameters  None  Return  None", 
            "title": "end()"
        }, 
        {
            "location": "/libraries/SPI/#begintransaction", 
            "text": "Description  Initializes the SPI bus using the defined  SPISettings .  Syntax  SPI.beginTransaction(mySettings);  Parameters   mySettings: the chosen settings according to SPISettings.   Return  None", 
            "title": "beginTransaction()"
        }, 
        {
            "location": "/libraries/SPI/#endtransaction", 
            "text": "Description  Stop using the SPI bus. Normally this is called after de-asserting the chip select, to allow other libraries to use the SPI bus.  Syntax  SPI.endTransaction()  Parameters  None  Return  None", 
            "title": "endTransaction()"
        }, 
        {
            "location": "/libraries/SPI/#setbitorder", 
            "text": "Description  Sets the order of the bits shifted out of and into the SPI bus, either LSBFIRST (least-significant bit first) or MSBFIRST (most-significant bit first).  Syntax  SPI.setBitOrder(order)  Parameters   order: either LSBFIRST or MSBFIRST   Return  None", 
            "title": "setBitOrder()"
        }, 
        {
            "location": "/libraries/SPI/#setclockdivider", 
            "text": "Description  Sets the SPI clock divider relative to the system clock. The dividers available are 2, 4, 8, 16, 32, 64 or 128. The default setting is SPI_CLOCK_DIV4, which sets the SPI clock to one-quarter the frequency of the Arduino system clock (4 Mhz for the boards at 16 MHz).  Syntax  SPI.setClockDivider(divider)  Parameters   divider:  SPI_CLOCK_DIV2 (8MHz)  SPI_CLOCK_DIV4 (4MHz, default)  SPI_CLOCK_DIV8 (2MHz)  SPI_CLOCK_DIV16 (1MHz)  SPI_CLOCK_DIV32 (500kHz)   SPI_CLOCK_DIV64 (250kHz)  SPI_CLOCK_DIV128 (125kHz)     Return  None", 
            "title": "setClockDivider()"
        }, 
        {
            "location": "/libraries/SPI/#setdatamode", 
            "text": "Description  Sets the SPI data mode: that is, clock polarity and phase. See the  Wikipedia article on SPI  for details.  Syntax  SPI.setDataMode(mode)  Parameters   mode:      SPI_MODE0  SPI_MODE1  SPI_MODE2  SPI_MODE3     Return  None", 
            "title": "setDataMode()"
        }, 
        {
            "location": "/libraries/SPI/#transfer", 
            "text": "Description  SPI transfer is based on a simultaneous send and receive: the received data is returned in receivedVal (or receivedVal16). In case of buffer transfers the received data is stored in the buffer in-place (the old data is replaced with the data received).  Syntax  receivedVal = SPI.transfer(val)  SPI.transfer(buffer, size)  Parameters    val: the byte to send out over the bus    buffer: the array of data to be transferred    Return  the received data", 
            "title": "transfer()"
        }, 
        {
            "location": "/libraries/Timer/", 
            "text": "CT-ARM has 4 built-in hardware timers: \nTimer1\n, \nTimer2\n, \nTimer3\n and \nTimer4\n. These timers do not interfere with functions like \ndelay()\n, \ndelayMicroseconds()\n, \nmillis()\n and \nmicros()\n. This Timer library allows users to use timer interrupts for program routines.\n\n\n\n\nNote\n\n\nTone library uses Timer2, so make sure that you do not use Timer2 interrupts with function \nTone()\n\n\n\n\ninitialize()\n\n\nDescription\n\n\nYou must call this method first to use any of the other methods. You can optionally specify the timer's period here (in microseconds), by default it is set at 1 second.\n\n\nSyntax\n\n\nTimer1.initialize(period)\n\n\nAlso applies to \nTimer2\n, \nTimer3\n and \nTimer4\n.\n\n\nParameters\n\n\n\n\nperiod: timer's period in microseconds, ranges from 2 to 16,777,216\n\n\n\n\nReturn\n\n\nNone\n\n\nattachInterrupt()\n\n\nDescription\n\n\nCalls a function at the specified time interval in microseconds. The time interval is set from \ninitialize()\n function. Be careful about trying to execute too complicated of an interrupt at too high of a frequency, or the CPU may never enter the main loop and your program will 'lock up'. \n\n\nSyntax\n\n\nTimer1.attachInterrupt(handler)\n\n\nAlso applies to \nTimer2\n, \nTimer3\n and \nTimer4\n.\n\n\nParameters\n\n\n\n\nhandler: the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.\n\n\n\n\nReturn\n\n\nNone\n\n\nExample\n\n\nvoid\n \nsetup\n()\n\n\n{\n\n  \npinMode\n(\n10\n,\n \nOUTPUT\n);\n\n  \nTimer1\n.\ninitialize\n(\n500000\n);\n         \n// initialize timer1, and set a 1/2 second period\n\n  \nTimer1\n.\nattachInterrupt\n(\ncallback\n);\n  \n// attaches callback() as a timer overflow interrupt\n\n\n}\n\n\n\nvoid\n \ncallback\n()\n\n\n{\n\n  \ndigitalWrite\n(\n10\n,\n \ndigitalRead\n(\n10\n)\n \n^\n \n1\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n\n\n{\n\n  \n// your program here...\n\n\n}\n\n\n\n\n\n\ndetachInterrupt()\n\n\nDescription\n\n\nDisables the attached interrupt.\n\n\nSyntax\n\n\nTimer1.detachInterrupt()\n\n\nAlso applies to \nTimer2\n, \nTimer3\n and \nTimer4\n.\n\n\nParameters\n\n\nNone\n\n\nReturn\n\n\nNone", 
            "title": "Timer"
        }, 
        {
            "location": "/libraries/Timer/#initialize", 
            "text": "Description  You must call this method first to use any of the other methods. You can optionally specify the timer's period here (in microseconds), by default it is set at 1 second.  Syntax  Timer1.initialize(period)  Also applies to  Timer2 ,  Timer3  and  Timer4 .  Parameters   period: timer's period in microseconds, ranges from 2 to 16,777,216   Return  None", 
            "title": "initialize()"
        }, 
        {
            "location": "/libraries/Timer/#attachinterrupt", 
            "text": "Description  Calls a function at the specified time interval in microseconds. The time interval is set from  initialize()  function. Be careful about trying to execute too complicated of an interrupt at too high of a frequency, or the CPU may never enter the main loop and your program will 'lock up'.   Syntax  Timer1.attachInterrupt(handler)  Also applies to  Timer2 ,  Timer3  and  Timer4 .  Parameters   handler: the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.   Return  None  Example  void   setup ()  { \n   pinMode ( 10 ,   OUTPUT ); \n   Timer1 . initialize ( 500000 );           // initialize timer1, and set a 1/2 second period \n   Timer1 . attachInterrupt ( callback );    // attaches callback() as a timer overflow interrupt  }  void   callback ()  { \n   digitalWrite ( 10 ,   digitalRead ( 10 )   ^   1 );  }  void   loop ()  { \n   // your program here...  }", 
            "title": "attachInterrupt()"
        }, 
        {
            "location": "/libraries/Timer/#detachinterrupt", 
            "text": "Description  Disables the attached interrupt.  Syntax  Timer1.detachInterrupt()  Also applies to  Timer2 ,  Timer3  and  Timer4 .  Parameters  None  Return  None", 
            "title": "detachInterrupt()"
        }, 
        {
            "location": "/FAQs/", 
            "text": "Can I use the same program written for Arduino Uno in CT-ARM?\n\n\n\n\nIt depends. at most time it is compatible, unless the program uses libraries which are AVR-specific, then CT-ARM cannot support because it uses ARM architecture.\n\n\n\n\nCan I use the libraries developed for Arduino in CT-ARM program\n\n\n\n\nYes, as long as the libraries are not AVR-specific. Mostly basic/common libraries can work in CT-ARM as they should be. Some libraries may be platform-dependent, you can seek for assistance or patches to add CT-ARM platform into library you are using.\n\n\n\n\nWhat are the advantages of using CT-ARM instead of Arduino Uno?\n\n\n\n\nCT-ARM provides more RAM and program memory, allowing users to compile larger size of code in their projects. CT-ARM also provides a few more peripherals that Uno doesn't offer, such as more hardware Serials, separate SPI and I2C peripherals from digital I/O pins, etc.\n\n\n\n\nWhere can I post the issue if I have problems programming in CT-ARM?\n\n\n\n\nYou can visit our \nCT-ARM GitHub page\n to post a new issue. We will get back to you as soon as possible!", 
            "title": "FAQs"
        }, 
        {
            "location": "/Bugs_and_Fixes/", 
            "text": "1.1.0 (16/4/2018)\n\n\nBug Fixes\n\n\n\n\nFixed program memory sudden rise issue during program compilation\n\n\nRetidy Servo library\n\n\n\n\nChanges\n\n\n\n\nChange pin mapping of analog, I2C and SPI, but still backward compatible\n\n\n\n\nNew\n\n\n\n\nAdded Firmata compatibility\n\n\n\n\n1.0.1 (18/4/2017)\n\n\nBug Fixes\n\n\n\n\nExternal interrupts now can be applied on all pins\n\n\nSoftwareSerial now can be used on all pins, tested works stable at 9600 baud or lower\n\n\nFixed the analogReadResolution issue, by default now gives 10 bit resolution\n\n\n\n\nNew\n\n\n\n\nAdded ShiftIn and ShiftOut", 
            "title": "Bugs and Fixes"
        }, 
        {
            "location": "/Bugs_and_Fixes/#110-1642018", 
            "text": "", 
            "title": "1.1.0 (16/4/2018)"
        }, 
        {
            "location": "/Bugs_and_Fixes/#bug-fixes", 
            "text": "Fixed program memory sudden rise issue during program compilation  Retidy Servo library", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/Bugs_and_Fixes/#changes", 
            "text": "Change pin mapping of analog, I2C and SPI, but still backward compatible", 
            "title": "Changes"
        }, 
        {
            "location": "/Bugs_and_Fixes/#new", 
            "text": "Added Firmata compatibility", 
            "title": "New"
        }, 
        {
            "location": "/Bugs_and_Fixes/#101-1842017", 
            "text": "", 
            "title": "1.0.1 (18/4/2017)"
        }, 
        {
            "location": "/Bugs_and_Fixes/#bug-fixes_1", 
            "text": "External interrupts now can be applied on all pins  SoftwareSerial now can be used on all pins, tested works stable at 9600 baud or lower  Fixed the analogReadResolution issue, by default now gives 10 bit resolution", 
            "title": "Bug Fixes"
        }, 
        {
            "location": "/Bugs_and_Fixes/#new_1", 
            "text": "Added ShiftIn and ShiftOut", 
            "title": "New"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "MIT License\n\n\nCopyright \n 2016 - 2017 Cytron Technologies\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "License"
        }
    ]
}